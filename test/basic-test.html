<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
    <script src="../../webcomponentsjs/webcomponents-loader.js"></script>
    <script src="../../web-component-tester/browser.js"></script>
    <!-- Polyfills for IE11 <\3 -->
    <link rel="import" href="../../arc-polyfills/arc-polyfills.html">
    <link rel="import" href="../api-view-model-transformer.html">
  </head>
  <body>
    <test-fixture id="basic">
      <template>
        <api-view-model-transformer></api-view-model-transformer>
      </template>
    </test-fixture>

    <test-fixture id="Manual">
      <template>
        <api-view-model-transformer manual-model></api-view-model-transformer>
      </template>
    </test-fixture>

    <script>
    suite('Basic tests', () => {
      let element;
      test('manualModel is undefined by default', () => {
        element = fixture('basic');
        assert.isUndefined(element.manualModel);
      });

      test('Calls computeViewModel() when shape changes', (done) => {
        element = fixture('basic');
        element.computeViewModel = () => {
          done();
        };
        element.shape = [];
      });

      test('Do not call computeViewModel() when is manual', () => {
        element = fixture('Manual');
        let called = false;
        element.computeViewModel = () => {
          called = true;
        };
        assert.isFalse(called);
      });

      test('Computes _references', () => {
        element = fixture('basic');
        element.amfModel = [{
          'http://a.ml/vocabularies/document#references': ['test']
        }];
        assert.typeOf(element._references, 'array');
        assert.equal(element._references[0], 'test');
      });
    });

    suite('_hasType()', () => {
      let element;
      const model = {
        '@type': [
          'one',
          'two',
          'three'
        ]
      };
      setup(() => {
        element = fixture('basic');
      });

      test('Return false for undefined model', () => {
        const result = element._hasType(undefined, '');
        assert.isFalse(result);
      });

      test('Return false for empty model', () => {
        const result = element._hasType([], '');
        assert.isFalse(result);
      });

      test('Return true for existing type', () => {
        const result = element._hasType(model, 'two');
        assert.isTrue(result);
      });

      test('Return false for missing type', () => {
        const result = element._hasType(model, 'some');
        assert.isFalse(result);
      });
    });

    suite('_computeBinding()', () => {
      let element;
      const model = {
        'http://a.ml/vocabularies/http#binding': [{
          '@value': 'test-value'
        }]
      };
      suiteSetup(() => {
        element = fixture('basic');
      });

      test('Returns undefined when no binding', () => {
        const result = element._computeBinding({});
        assert.isUndefined(result);
      });

      test('Returns binding value', () => {
        const result = element._computeBinding(model);
        assert.equal(result, 'test-value');
      });
    });

    suite('_computeFormName()', () => {
      let element;
      const model = {
        'http://schema.org/name': [{
          '@value': 'test-value'
        }]
      };
      suiteSetup(() => {
        element = fixture('basic');
      });

      test('Returns undefined when no name', () => {
        const result = element._computeFormName({});
        assert.isUndefined(result);
      });

      test('Returns name value', () => {
        const result = element._computeFormName(model);
        assert.equal(result, 'test-value');
      });
    });

    suite('_computeDescription()', () => {
      let element;
      const model = {
        'http://schema.org/description': [{
          '@value': 'test-value'
        }]
      };
      suiteSetup(() => {
        element = fixture('basic');
      });

      test('Returns undefined when no name', () => {
        const result = element._computeDescription({});
        assert.isUndefined(result);
      });

      test('Returns description value', () => {
        const result = element._computeDescription(model);
        assert.equal(result, 'test-value');
      });
    });

    suite('_computeRequired()', () => {
      let element;
      const model = {
        'http://www.w3.org/ns/hydra/core#required': [{
          '@value': 'test-value'
        }]
      };
      suiteSetup(() => {
        element = fixture('basic');
      });

      test('Returns undefined when no name', () => {
        const result = element._computeRequired({});
        assert.isUndefined(result);
      });

      test('Returns required value', () => {
        const result = element._computeRequired(model);
        assert.equal(result, 'test-value');
      });
    });

    suite('_computeModelType()', () => {
      let element;

      suiteSetup(() => {
        element = fixture('basic');
      });

      test('Returns default value', () => {
        const result = element._computeModelType({});
        assert.equal(result, 'string');
      });

      test('Computes UnionShape', () => {
        const type = 'http://a.ml/vocabularies/shapes#UnionShape';
        const result = element._computeModelType({
          '@type': [type]
        });
        assert.equal(result, 'union');
      });

      test('Computes ArrayShape', () => {
        const type = 'http://a.ml/vocabularies/shapes#ArrayShape';
        const result = element._computeModelType({
          '@type': [type]
        });
        assert.equal(result, 'array');
      });

      test('Computes NodeShape', () => {
        const type = 'http://www.w3.org/ns/shacl#NodeShape';
        const result = element._computeModelType({
          '@type': [type]
        });
        assert.equal(result, 'object');
      });

      test('Computes FileShape', () => {
        const type = 'http://a.ml/vocabularies/shapes#FileShape';
        const result = element._computeModelType({
          '@type': [type]
        });
        assert.equal(result, 'file');
      });

      test('Computes NilShape', () => {
        const type = 'http://a.ml/vocabularies/shapes#NilShape';
        const result = element._computeModelType({
          '@type': [type]
        });
        assert.equal(result, 'null');
      });

      test('Computes AnyShape', () => {
        const type = 'http://a.ml/vocabularies/shapes#AnyShape';
        const result = element._computeModelType({
          '@type': [type]
        });
        assert.equal(result, 'string');
      });

      test('Computes MatrixShape', () => {
        const type = 'http://a.ml/vocabularies/shapes#MatrixShape';
        const result = element._computeModelType({
          '@type': [type]
        });
        assert.equal(result, 'array');
      });

      test('Computes TupleShape', () => {
        const type = 'http://a.ml/vocabularies/shapes#TupleShape';
        const result = element._computeModelType({
          '@type': [type]
        });
        assert.equal(result, 'object');
      });
    });

    suite('_computeModelType() - ScalarShape', () => {
      let element;
      let shape = {
        '@type': ['http://a.ml/vocabularies/shapes#ScalarShape'],
        'http://www.w3.org/ns/shacl#datatype': [{
          '@id': ''
        }]
      };
      suiteSetup(() => {
        element = fixture('basic');
      });
      function setType(type) {
        shape['http://www.w3.org/ns/shacl#datatype'][0]['@id'] = type;
      }
      [
        ['http://a.ml/vocabularies/shapes#number', 'number'],
        ['http://www.w3.org/2001/XMLSchema#integer', 'integer'],
        ['http://www.w3.org/2001/XMLSchema#string', 'string'],
        ['http://www.w3.org/2001/XMLSchema#boolean', 'boolean'],
        ['http://www.w3.org/2001/XMLSchema#date', 'date'],
        ['http://www.w3.org/2001/XMLSchema#time', 'time'],
        ['http://www.w3.org/2001/XMLSchema#dateTime', 'datetime'],
        ['http://a.ml/vocabularies/shapes#dateTimeOnly', 'datetime-only'],
        ['http://www.w3.org/2001/XMLSchema#float', 'float'],
        ['http://www.w3.org/2001/XMLSchema#long', 'long'],
        ['http://www.w3.org/2001/XMLSchema#double', 'double'],
        ['http://www.w3.org/2001/XMLSchema#base64Binary', 'string'],
        ['http://a.ml/vocabularies/shapes#password', 'password'],
        ['UNKNOWN', 'string']
      ].forEach((item) => {
        test('Computes ' + item[0], () => {
          setType(item[0]);
          const result = element._computeModelType(shape);
          assert.equal(result, item[1]);
        });
      });
    });


    suite('_computeInputLabel()', () => {
      let element;
      suiteSetup(() => {
        element = fixture('basic');
      });

      test('Finds name in the model', () => {
        const result = element._computeInputLabel({
          'http://schema.org/name': [{
            '@value': 'test-name'
          }]
        });
        assert.equal(result, 'test-name');
      });

      test('Adds asterix when required', () => {
        const result = element._computeInputLabel({
          'http://schema.org/name': [{
            '@value': 'test-name'
          }]
        }, true);
        assert.equal(result, 'test-name*');
      });

      test('Uses property name when display name not found', () => {
        const result = element._computeInputLabel({
          'blank': 'test-name'
        }, false, 'other-name');
        assert.equal(result, 'other-name');
      });

      test('Uses default value', () => {
        const result = element._computeInputLabel({}, false, undefined);
        assert.equal(result, 'Input value');
      });
    });

    suite('_computeShaclProperty()', () => {
      const key = 'http://www.w3.org/ns/shacl#';

      let element;
      suiteSetup(() => {
        element = fixture('basic');
      });

      test('returns undefined for missing model', () => {
        const result = element._computeShaclProperty();
        assert.isUndefined(result);
      });

      test('returns undefined for missing property', () => {
        const result = element._computeShaclProperty({}, 'test');
        assert.isUndefined(result);
      });

      test('returns value of the property', () => {
        const shape = {};
        shape[key + 'test-key'] = [{'@value': 'test-value'}];
        const result = element._computeShaclProperty(shape, 'test-key');
        assert.equal(result, 'test-value');
      });
    });

    suite('_computeVocabularyShapeProperty()', () => {
      const key = 'http://a.ml/vocabularies/shapes#';

      let element;
      suiteSetup(() => {
        element = fixture('basic');
      });

      test('returns undefined for missing model', () => {
        const result = element._computeVocabularyShapeProperty();
        assert.isUndefined(result);
      });

      test('returns undefined for missing property', () => {
        const result = element._computeVocabularyShapeProperty({}, 'test');
        assert.isUndefined(result);
      });

      test('returns value of the property', () => {
        const shape = {};
        shape[key + 'test-key'] = [{'@value': 'test-value'}];
        const result = element._computeVocabularyShapeProperty(shape, 'test-key');
        assert.equal(result, 'test-value');
      });
    });

    suite('_computeModelEnum()', () => {
      let element;
      let model;
      suiteSetup(() => {
        element = fixture('basic');
        model = {
          'http://www.w3.org/ns/shacl#in': [{
            '@id': 'file://models/demo-api/demo-api.raml#/web-api/end-points/%2Fpeople%2F%7BpersonId%7D/get/request/parameter/x-enum/scalar/schema/list',
            '@type': 'http://www.w3.org/2000/01/rdf-schema#Seq',
            'http://www.w3.org/2000/01/rdf-schema#_1': [{
              '@id': 'amf://id#635',
              '@type': [
                'http://a.ml/vocabularies/data#Scalar'
              ],
              'http://a.ml/vocabularies/data#value': [
                {
                  '@value': 'a',
                  '@type': 'http://www.w3.org/2001/XMLSchema#string'
                }
              ]
            }],
            'http://www.w3.org/2000/01/rdf-schema#_2': [{
              '@id': 'amf://id#636',
              '@type': [
                'http://a.ml/vocabularies/data#Scalar'
              ],
              'http://a.ml/vocabularies/data#value': [
                {
                  '@value': 'b',
                  '@type': 'http://www.w3.org/2001/XMLSchema#string'
                }
              ]
            }],
            'http://www.w3.org/2000/01/rdf-schema#_3': [{
              '@id': 'amf://id#637',
              '@type': [
                'http://a.ml/vocabularies/data#Scalar'
              ],
              'http://a.ml/vocabularies/data#value': [
                {
                  '@value': 'c',
                  '@type': 'http://www.w3.org/2001/XMLSchema#string'
                }
              ]
            }]
          }]
        };
      });

      test('Returns array', () => {
        const result = element._computeModelEnum(model);
        assert.typeOf(result, 'array');
      });

      test('Array has all items from model', () => {
        const result = element._computeModelEnum(model);
        assert.lengthOf(result, 3);
      });

      test('Items are in order', () => {
        const result = element._computeModelEnum(model);
        assert.deepEqual(result, ['a', 'b', 'c']);
      });
    });

    suite('_computeModelPattern()', () => {
      let element;
      suiteSetup(() => {
        element = fixture('basic');
      });

      test('Always returns pattern if provided', () => {
        const result = element._computeModelPattern('time', 'test-pattern');
        assert.equal(result, 'test-pattern');
      });

      test('Returns pattern for time type', () => {
        const result = element._computeModelPattern('time');
        assert.equal(result, '^[0-9]{2}:[0-9]{2}:[0-9]{2}\.?[0-9]{0,3}$');
      });

      test('time pattern matches "partial-time" notation of RFC3339', () => {
        const result = element._computeModelPattern('time');
        const reg = new RegExp(result);
        assert.isTrue(reg.test('00:00:00'), 'Matches HH:mm:ss');
        assert.isTrue(reg.test('00:00:00.0'), 'Matches HH:mm:ss.f');
        assert.isTrue(reg.test('00:00:00.00'), 'Matches HH:mm:ss.ff');
        assert.isTrue(reg.test('00:00:00.000'), 'Matches HH:mm:ss.fff');
        assert.isFalse(reg.test('00:00:00.00Z'), 'Does not matches time zone');
        assert.isFalse(reg.test('00:00'), 'Full time is required');
      });

      test('Returns pattern for date type', () => {
        const result = element._computeModelPattern('date');
        assert.equal(result, '^[0-9]{4}-[0-9]{2}-[0-9]{2}$');
      });

      test('date pattern matches "full-date" notation of RFC3339', () => {
        const result = element._computeModelPattern('date');
        const reg = new RegExp(result);
        assert.isTrue(reg.test('0000-00-00'), 'Matches YYYY-MM-DD');
        assert.isFalse(reg.test('00:00:00.00T00:00:00'), 'Does not matches time');
        assert.isFalse(reg.test('0000-00'), 'Full date is required');
      });

      test('Returns pattern for datetime-only type', () => {
        const result = element._computeModelPattern('datetime-only');
        assert.equal(result, '^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}\.?[0-9]{0,3}$');
      });

      test('datetime-only pattern matches "full-date" and "partial-time" notation of RFC3339', () => {
        const result = element._computeModelPattern('datetime-only');
        const reg = new RegExp(result);
        assert.isTrue(reg.test('0000-00-00T00:00:00'), 'Matches YYYY-MM-DDTHH:mm:ss');
        assert.isTrue(reg.test('0000-00-00T00:00:00.0'), 'Matches YYYY-MM-DDTHH:mm:ss.f');
        assert.isTrue(reg.test('0000-00-00T00:00:00.00'), 'Matches YYYY-MM-DDTHH:mm:ss.ff');
        assert.isTrue(reg.test('0000-00-00T00:00:00.000'), 'Matches YYYY-MM-DDTHH:mm:ss.fff');
        assert.isFalse(reg.test('0000-00-00T00:00:00.00Z'), 'Does not matches time zone');
        assert.isFalse(reg.test('0000-00-00T00'), 'Full date + time is required');
      });

      test('Returns pattern for datetime type, default format', () => {
        const result = element._computeModelPattern('datetime');
        assert.equal(result, '^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}.*$');
      });

      test('Pattern for datetime type and rfc2616 format is empty', () => {
        const result = element._computeModelPattern('datetime', undefined, 'rfc2616');
        assert.equal(result, '');
      });

      test('_computeTypePlaceholder()', () => {
        let element;
        suiteSetup(() => {
          element = fixture('basic');
        });

        test('Returns placeholder value for time', () => {
          const result = element._computeTypePlaceholder('time');
          assert.equal(result, '00:00:00.000');
        });

        test('Returns placeholder value for date', () => {
          const result = element._computeTypePlaceholder('date');
          assert.equal(result, '0000-00-00');
        });

        test('Returns placeholder value for datetime-only', () => {
          const result = element._computeTypePlaceholder('datetime-only');
          assert.equal(result, '0000-00-00T00:00:00.000');
        });

        test('Returns placeholder value for datetime, default format', () => {
          const result = element._computeTypePlaceholder('datetime');
          assert.equal(result, '0000-00-00T00:00:00Z+01:00');
        });

        test('Returns placeholder value for datetime, rfc2616 format', () => {
          const result = element._computeTypePlaceholder('datetime');
          assert.equal(result, 'Sun, 01 Jan 2000 00:00:00 GMT');
        });
      });
    });

    suite('_buildPropertyHandler()', () => {
      let element;
      setup(() => {
        element = fixture('basic');
      });

      test('Do nothing when event is prevented', () => {
        let called = false;
        element.buildProperty = () => called = true;
        element._buildPropertyHandler({
          defaultPrevented: true
        });
        assert.isFalse(called);
      });

      test('Calls buildProperty() function', () => {
        let called = false;
        element.buildProperty = () => called = true;
        element._buildPropertyHandler({
          stopImmediatePropagation: () => {},
          preventDefault: () => {}
        });
        assert.isTrue(called);
      });

      test('Calls buildProperty() function with the detail object', () => {
        let passedData;
        element.buildProperty = (arg) => passedData = arg;
        element._buildPropertyHandler({
          stopImmediatePropagation: () => {},
          preventDefault: () => {},
          detail: {test: true}
        });
        assert.deepEqual(passedData, {test: true});
      });

      test('Prevents event defaults', () => {
        let called = false;
        element.buildProperty = () => {};
        element._buildPropertyHandler({
          stopImmediatePropagation: () => {},
          preventDefault: () => called = true
        });
        assert.isTrue(called);
      });

      test('Stops propagation of the event', () => {
        let called = false;
        element.buildProperty = () => {};
        element._buildPropertyHandler({
          stopImmediatePropagation: () => called = true,
          preventDefault: () => {}
        });
        assert.isTrue(called);
      });
    });

    suite('buildProperty()', () => {
      let element;
      suiteSetup(() => {
        element = fixture('basic');
      });

      test('Returns an object', () => {
        const result = element.buildProperty();
        assert.typeOf(result, 'object');
      });

      test('object has schema', () => {
        const result = element.buildProperty();
        assert.typeOf(result.schema, 'object');
      });

      test('Default schema.type is string', () => {
        const result = element.buildProperty();
        assert.equal(result.schema.type, 'string');
      });

      test('Default schema.isEnum is false', () => {
        const result = element.buildProperty();
        assert.isFalse(result.schema.isEnum);
      });

      test('Default schema.isArray is false', () => {
        const result = element.buildProperty();
        assert.isFalse(result.schema.isArray);
      });

      test('Default schema.isBool is false', () => {
        const result = element.buildProperty();
        assert.isFalse(result.schema.isBool);
      });

      test('Default schema.isFile is false', () => {
        const result = element.buildProperty();
        assert.isFalse(result.schema.isFile);
      });

      test('Default schema.inputType is text', () => {
        const result = element.buildProperty();
        assert.equal(result.schema.inputType, 'text');
      });

      test('Default schema.inputFloatLabel is false', () => {
        const result = element.buildProperty();
        assert.isFalse(result.schema.inputFloatLabel);
      });

      test('Default hasDescription is false', () => {
        const result = element.buildProperty();
        assert.isFalse(result.hasDescription);
      });
    });

    suite('_computeHasExtendedDocumentation()', () => {
      let element;
      suiteSetup(() => {
        element = fixture('basic');
      });

      test('Returns true when "hasDescription"', () => {
        const result = element._computeHasExtendedDocumentation({
          hasDescription: true
        });
        assert.isTrue(result);
      });

      test('Returns false when no "schema"', () => {
        const result = element._computeHasExtendedDocumentation({});
        assert.isFalse(result);
      });

      test('Returns true when "schema.pattern"', () => {
        const result = element._computeHasExtendedDocumentation({
          schema: {
            pattern: 'test'
          }
        });
        assert.isTrue(result);
      });

      test('Returns true when "schema.examples"', () => {
        const result = element._computeHasExtendedDocumentation({
          schema: {
            examples: ['test']
          }
        });
        assert.isTrue(result);
      });

      test('Returns false otherwise', () => {
        const result = element._computeHasExtendedDocumentation({
          schema: {}
        });
        assert.isFalse(result);
      });
    });

    suite('_computeExtendedDocumentation()', () => {
      let element;
      suiteSetup(() => {
        element = fixture('basic');
      });

      test('Returns empty string when no schema and description', () => {
        const result = element._computeExtendedDocumentation({});
        assert.equal(result, '');
      });

      test('Returns description only when no schema', () => {
        const result = element._computeExtendedDocumentation({
          description: 'test'
        });
        assert.equal(result, 'test');
      });

      test('Adds pattern to description', () => {
        const result = element._computeExtendedDocumentation({
          description: 'test',
          schema: {
            pattern: 'test'
          }
        });
        assert.equal(result, 'test\n\n\n- Pattern: `test`\n');
      });

      test('Returns pattern only to description', () => {
        const result = element._computeExtendedDocumentation({
          schema: {
            pattern: 'test'
          }
        });
        assert.equal(result, '- Pattern: `test`\n');
      });

      test('Returns exampels', () => {
        const result = element._computeExtendedDocumentation({
          schema: {
            examples: [{
              hasName: true,
              name: 'test-name',
              value: 'test-example'
            }]
          }
        });
        assert.equal(result, '- Example test-name: `test-example`\n');
      });
    });

    suite('_computeModelItems()', () => {
      let element;
      suiteSetup(() => {
        element = fixture('basic');
      });

      test('Returns undefined if object is not #ArrayShape', () => {
        const result = element._computeModelItems({});
        assert.isUndefined(result);
      });

      test('Returns undefined when no items declaration', () => {
        const obj = {};
        obj['@type'] = [element.ns.raml.vocabularies.shapes + 'ArrayShape'];
        const result = element._computeModelItems(obj);
        assert.isUndefined(result);
      });

      test('Returns "string"', () => {
        const obj = {};
        obj['@type'] = [element.ns.raml.vocabularies.shapes + 'ArrayShape'];
        obj[element.ns.raml.vocabularies.shapes + 'items'] = [{}];
        const result = element._computeModelItems(obj);
        assert.equal(result, 'string');
      });
    });

    suite('_computeModelInputType()', () => {
      let element;
      suiteSetup(() => {
        element = fixture('basic');
      });

      test('Returns "text" when no items and array', () => {
        const result = element._computeModelInputType('array');
        assert.equal(result, 'text');
      });

      test('Returns "items.type" when array', () => {
        const result = element._computeModelInputType('array', {
          type: 'number'
        });
        assert.equal(result, 'number');
      });

      test('Returns "items.schema.type" when array', () => {
        const result = element._computeModelInputType('array', {
          schema: {
            type: 'boolean'
          }
        });
        assert.equal(result, 'boolean');
      });
    });
    </script>

  </body>
</html>

<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
    <script src="../../webcomponentsjs/webcomponents-loader.js"></script>
    <script src="../../web-component-tester/browser.js"></script>
    <!-- Polyfills for IE11 <\3 -->
    <link rel="import" href="../../arc-polyfills/arc-polyfills.html">
    <link rel="import" href="../api-view-model-transformer.html">
  </head>
  <body>
    <test-fixture id="basic">
      <template>
        <api-view-model-transformer></api-view-model-transformer>
      </template>
    </test-fixture>
    <test-fixture id="Manual">
      <template>
        <api-view-model-transformer></api-view-model-transformer>
      </template>
    </test-fixture>
    <script>
    suite('Basic tests', () => {
      let element;
      test('manualModel is undefined by default', () => {
        element = fixture('basic');
        assert.isUndefined(element.manualModel);
      });

      test('Calls computeViewModel() when shape changes', (done) => {
        element = fixture('basic');
        element.computeViewModel = () => {
          done();
        };
        element.shape = [];
      });

      test('Does not call computeViewModel() when is manual', () => {
        element = fixture('Manual');
        let called = false;
        element.computeViewModel = () => {
          called = true;
        };
        assert.isFalse(called);
      });

      test('Computes _references', () => {
        element = fixture('basic');
        element.amfModel = [{
          'http://a.ml/vocabularies/document#references': ['test']
        }];
        assert.typeOf(element._references, 'array');
        assert.equal(element._references[0], 'test');
      });
    });

    suite('_hasType()', () => {
      let element;
      const model = {
        '@type': [
          'one',
          'two',
          'three'
        ]
      };
      setup(() => {
        element = fixture('basic');
      });

      test('Return false for undefined model', () => {
        const result = element._hasType(undefined, '');
        assert.isFalse(result);
      });

      test('Return false for empty model', () => {
        const result = element._hasType([], '');
        assert.isFalse(result);
      });

      test('Return true for existing type', () => {
        const result = element._hasType(model, 'two');
        assert.isTrue(result);
      });

      test('Return false for missing type', () => {
        const result = element._hasType(model, 'some');
        assert.isFalse(result);
      });
    });

    suite('_computeBinding()', () => {
      let element;
      const model = {
        'http://a.ml/vocabularies/http#binding': [{
          '@value': 'test-value'
        }]
      };
      suiteSetup(() => {
        element = fixture('basic');
      });

      test('Returns undefined when no binding', () => {
        const result = element._computeBinding({});
        assert.isUndefined(result);
      });

      test('Returns binding value', () => {
        const result = element._computeBinding(model);
        assert.equal(result, 'test-value');
      });
    });

    suite('_computeFormName()', () => {
      let element;
      const model = {
        'http://schema.org/name': [{
          '@value': 'test-value'
        }]
      };
      suiteSetup(() => {
        element = fixture('basic');
      });

      test('Returns undefined when no name', () => {
        const result = element._computeFormName({});
        assert.isUndefined(result);
      });

      test('Returns name value', () => {
        const result = element._computeFormName(model);
        assert.equal(result, 'test-value');
      });
    });

    suite('_computeDescription()', () => {
      let element;
      const model = {
        'http://schema.org/description': [{
          '@value': 'test-value'
        }]
      };
      suiteSetup(() => {
        element = fixture('basic');
      });

      test('Returns undefined when no name', () => {
        const result = element._computeDescription({});
        assert.isUndefined(result);
      });

      test('Returns description value', () => {
        const result = element._computeDescription(model);
        assert.equal(result, 'test-value');
      });
    });

    suite('_computeRequired()', () => {
      let element;
      const model = {
        'http://www.w3.org/ns/hydra/core#required': [{
          '@value': 'test-value'
        }]
      };
      suiteSetup(() => {
        element = fixture('basic');
      });

      test('Returns undefined when no name', () => {
        const result = element._computeRequired({});
        assert.isUndefined(result);
      });

      test('Returns required value', () => {
        const result = element._computeRequired(model);
        assert.equal(result, 'test-value');
      });
    });

    suite('_computeModelType()', () => {
      let element;

      suiteSetup(() => {
        element = fixture('basic');
      });

      test('Returns default value', () => {
        const result = element._computeModelType({});
        assert.equal(result, 'string');
      });

      test('Computes UnionShape', () => {
        const type = 'http://a.ml/vocabularies/shapes#UnionShape';
        const result = element._computeModelType({
          '@type': [type]
        });
        assert.equal(result, 'union');
      });

      test('Computes ArrayShape', () => {
        const type = 'http://a.ml/vocabularies/shapes#ArrayShape';
        const result = element._computeModelType({
          '@type': [type]
        });
        assert.equal(result, 'array');
      });

      test('Computes NodeShape', () => {
        const type = 'http://www.w3.org/ns/shacl#NodeShape';
        const result = element._computeModelType({
          '@type': [type]
        });
        assert.equal(result, 'object');
      });

      test('Computes FileShape', () => {
        const type = 'http://a.ml/vocabularies/shapes#FileShape';
        const result = element._computeModelType({
          '@type': [type]
        });
        assert.equal(result, 'file');
      });

      test('Computes NilShape', () => {
        const type = 'http://a.ml/vocabularies/shapes#NilShape';
        const result = element._computeModelType({
          '@type': [type]
        });
        assert.equal(result, 'null');
      });

      test('Computes AnyShape', () => {
        const type = 'http://a.ml/vocabularies/shapes#AnyShape';
        const result = element._computeModelType({
          '@type': [type]
        });
        assert.equal(result, 'string');
      });

      test('Computes MatrixShape', () => {
        const type = 'http://a.ml/vocabularies/shapes#MatrixShape';
        const result = element._computeModelType({
          '@type': [type]
        });
        assert.equal(result, 'array');
      });

      test('Computes TupleShape', () => {
        const type = 'http://a.ml/vocabularies/shapes#TupleShape';
        const result = element._computeModelType({
          '@type': [type]
        });
        assert.equal(result, 'object');
      });
    });

    suite('_computeModelType() - ScalarShape', () => {
      let element;
      let shape = {
        '@type': ['http://a.ml/vocabularies/shapes#ScalarShape'],
        'http://www.w3.org/ns/shacl#datatype': [{
          '@id': ''
        }]
      };
      suiteSetup(() => {
        element = fixture('basic');
      });
      function setType(type) {
        shape['http://www.w3.org/ns/shacl#datatype'][0]['@id'] = type;
      }
      [
        ['http://a.ml/vocabularies/shapes#number', 'number'],
        ['http://www.w3.org/2001/XMLSchema#integer', 'integer'],
        ['http://www.w3.org/2001/XMLSchema#string', 'string'],
        ['http://www.w3.org/2001/XMLSchema#boolean', 'boolean'],
        ['http://www.w3.org/2001/XMLSchema#date', 'date'],
        ['http://www.w3.org/2001/XMLSchema#time', 'time'],
        ['http://www.w3.org/2001/XMLSchema#dateTime', 'datetime'],
        ['http://a.ml/vocabularies/shapes#dateTimeOnly', 'datetime-only'],
        ['http://www.w3.org/2001/XMLSchema#float', 'float'],
        ['http://www.w3.org/2001/XMLSchema#long', 'long'],
        ['http://www.w3.org/2001/XMLSchema#double', 'double'],
        ['http://www.w3.org/2001/XMLSchema#base64Binary', 'string'],
        ['http://a.ml/vocabularies/shapes#password', 'password'],
        ['UNKNOWN', 'string']
      ].forEach((item) => {
        test('Computes ' + item[0], () => {
          setType(item[0]);
          const result = element._computeModelType(shape);
          assert.equal(result, item[1]);
        });
      });
    });


    suite('_computeInputLabel()', () => {
      let element;
      suiteSetup(() => {
        element = fixture('basic');
      });

      test('Finds name in the model', () => {
        const result = element._computeInputLabel({
          'http://schema.org/name': [{
            '@value': 'test-name'
          }]
        });
        assert.equal(result, 'test-name');
      });

      test('Adds asterix when required', () => {
        const result = element._computeInputLabel({
          'http://schema.org/name': [{
            '@value': 'test-name'
          }]
        }, true);
        assert.equal(result, 'test-name*');
      });

      test('Uses property name when display name not found', () => {
        const result = element._computeInputLabel({
          'blank': 'test-name'
        }, false, 'other-name');
        assert.equal(result, 'other-name');
      });

      test('Uses default value', () => {
        const result = element._computeInputLabel({}, false, undefined);
        assert.equal(result, 'Input value');
      });
    });

    suite('_computeShaclProperty()', () => {
      const key = 'http://www.w3.org/ns/shacl#';

      let element;
      suiteSetup(() => {
        element = fixture('basic');
      });

      test('returns undefined for missing model', () => {
        const result = element._computeShaclProperty();
        assert.isUndefined(result);
      });

      test('returns undefined for missing property', () => {
        const result = element._computeShaclProperty({}, 'test');
        assert.isUndefined(result);
      });

      test('returns value of the property', () => {
        const shape = {};
        shape[key + 'test-key'] = [{'@value': 'test-value'}];
        const result = element._computeShaclProperty(shape, 'test-key');
        assert.equal(result, 'test-value');
      });
    });

    suite('_computeVocabularyShapeProperty()', () => {
      const key = 'http://a.ml/vocabularies/shapes#';

      let element;
      suiteSetup(() => {
        element = fixture('basic');
      });

      test('returns undefined for missing model', () => {
        const result = element._computeVocabularyShapeProperty();
        assert.isUndefined(result);
      });

      test('returns undefined for missing property', () => {
        const result = element._computeVocabularyShapeProperty({}, 'test');
        assert.isUndefined(result);
      });

      test('returns value of the property', () => {
        const shape = {};
        shape[key + 'test-key'] = [{'@value': 'test-value'}];
        const result = element._computeVocabularyShapeProperty(shape, 'test-key');
        assert.equal(result, 'test-value');
      });
    });

    suite('_computeModelEnum()', () => {
      let element;
      let model;
      suiteSetup(() => {
        element = fixture('basic');
        model = {
          'http://www.w3.org/ns/shacl#in': [{
            '@id': 'file://models/demo-api/demo-api.raml#/web-api/end-points/%2Fpeople%2F%7BpersonId%7D/get/request/parameter/x-enum/scalar/schema/list',
            '@type': 'http://www.w3.org/2000/01/rdf-schema#Seq',
            'http://www.w3.org/2000/01/rdf-schema#_1': [{
              '@id': 'amf://id#635',
              '@type': [
                'http://a.ml/vocabularies/data#Scalar'
              ],
              'http://a.ml/vocabularies/data#value': [
                {
                  '@value': 'a',
                  '@type': 'http://www.w3.org/2001/XMLSchema#string'
                }
              ]
            }],
            'http://www.w3.org/2000/01/rdf-schema#_2': [{
              '@id': 'amf://id#636',
              '@type': [
                'http://a.ml/vocabularies/data#Scalar'
              ],
              'http://a.ml/vocabularies/data#value': [
                {
                  '@value': 'b',
                  '@type': 'http://www.w3.org/2001/XMLSchema#string'
                }
              ]
            }],
            'http://www.w3.org/2000/01/rdf-schema#_3': [{
              '@id': 'amf://id#637',
              '@type': [
                'http://a.ml/vocabularies/data#Scalar'
              ],
              'http://a.ml/vocabularies/data#value': [
                {
                  '@value': 'c',
                  '@type': 'http://www.w3.org/2001/XMLSchema#string'
                }
              ]
            }]
          }]
        };
      });

      test('Returns array', () => {
        const result = element._computeModelEnum(model);
        assert.typeOf(result, 'array');
      });

      test('Array has all items from model', () => {
        const result = element._computeModelEnum(model);
        assert.lengthOf(result, 3);
      });

      test('Items are in order', () => {
        const result = element._computeModelEnum(model);
        assert.deepEqual(result, ['a', 'b', 'c']);
      });
    });

    suite('_computeModelPattern()', () => {
      let element;
      suiteSetup(() => {
        element = fixture('basic');
      });

      test('Always returns pattern if provided', () => {
        const result = element._computeModelPattern('time', 'test-pattern');
        assert.equal(result, 'test-pattern');
      });

      test('Returns pattern for time type', () => {
        const result = element._computeModelPattern('time');
        assert.equal(result, '^[0-9]{2}:[0-9]{2}:[0-9]{2}\.?[0-9]{0,3}$');
      });

      test('time pattern matches "partial-time" notation of RFC3339', () => {
        const result = element._computeModelPattern('time');
        const reg = new RegExp(result);
        assert.isTrue(reg.test('00:00:00'), 'Matches HH:mm:ss');
        assert.isTrue(reg.test('00:00:00.0'), 'Matches HH:mm:ss.f');
        assert.isTrue(reg.test('00:00:00.00'), 'Matches HH:mm:ss.ff');
        assert.isTrue(reg.test('00:00:00.000'), 'Matches HH:mm:ss.fff');
        assert.isFalse(reg.test('00:00:00.00Z'), 'Does not matches time zone');
        assert.isFalse(reg.test('00:00'), 'Full time is required');
      });

      test('Returns pattern for date type', () => {
        const result = element._computeModelPattern('date');
        assert.equal(result, '^[0-9]{4}-[0-9]{2}-[0-9]{2}$');
      });

      test('date pattern matches "full-date" notation of RFC3339', () => {
        const result = element._computeModelPattern('date');
        const reg = new RegExp(result);
        assert.isTrue(reg.test('0000-00-00'), 'Matches YYYY-MM-DD');
        assert.isFalse(reg.test('00:00:00.00T00:00:00'), 'Does not matches time');
        assert.isFalse(reg.test('0000-00'), 'Full date is required');
      });

      test('Returns pattern for datetime-only type', () => {
        const result = element._computeModelPattern('datetime-only');
        assert.equal(result, '^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}\.?[0-9]{0,3}$');
      });

      test('datetime-only pattern matches "full-date" and "partial-time" notation of RFC3339', () => {
        const result = element._computeModelPattern('datetime-only');
        const reg = new RegExp(result);
        assert.isTrue(reg.test('0000-00-00T00:00:00'), 'Matches YYYY-MM-DDTHH:mm:ss');
        assert.isTrue(reg.test('0000-00-00T00:00:00.0'), 'Matches YYYY-MM-DDTHH:mm:ss.f');
        assert.isTrue(reg.test('0000-00-00T00:00:00.00'), 'Matches YYYY-MM-DDTHH:mm:ss.ff');
        assert.isTrue(reg.test('0000-00-00T00:00:00.000'), 'Matches YYYY-MM-DDTHH:mm:ss.fff');
        assert.isFalse(reg.test('0000-00-00T00:00:00.00Z'), 'Does not matches time zone');
        assert.isFalse(reg.test('0000-00-00T00'), 'Full date + time is required');
      });

      test('Returns pattern for datetime type, default format', () => {
        const result = element._computeModelPattern('datetime');
        assert.equal(result, '^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}.*$');
      });

      test('Pattern for datetime type and rfc2616 format is empty', () => {
        const result = element._computeModelPattern('datetime', undefined, 'rfc2616');
        assert.equal(result, '');
      });

      test('_computeTypePlaceholder()', () => {
        let element;
        suiteSetup(() => {
          element = fixture('basic');
        });

        test('Returns placeholder value for time', () => {
          const result = element._computeTypePlaceholder('time');
          assert.equal(result, '00:00:00.000');
        });

        test('Returns placeholder value for date', () => {
          const result = element._computeTypePlaceholder('date');
          assert.equal(result, '0000-00-00');
        });

        test('Returns placeholder value for datetime-only', () => {
          const result = element._computeTypePlaceholder('datetime-only');
          assert.equal(result, '0000-00-00T00:00:00.000');
        });

        test('Returns placeholder value for datetime, default format', () => {
          const result = element._computeTypePlaceholder('datetime');
          assert.equal(result, '0000-00-00T00:00:00Z+01:00');
        });

        test('Returns placeholder value for datetime, rfc2616 format', () => {
          const result = element._computeTypePlaceholder('datetime');
          assert.equal(result, 'Sun, 01 Jan 2000 00:00:00 GMT');
        });
      });
    });

    </script>

  </body>
</html>

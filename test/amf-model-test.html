<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
    <script src="../../webcomponentsjs/webcomponents-loader.js"></script>
    <script src="../../web-component-tester/browser.js"></script>
    <!-- Polyfills for IE11 <\3 -->
    <link rel="import" href="../../arc-polyfills/arc-polyfills.html">
    <link rel="import" href="../api-view-model-transformer.html">
    <script src="amf-loader.js"></script>
  </head>
  <body>
    <test-fixture id="Basic">
      <template>
        <api-view-model-transformer></api-view-model-transformer>
      </template>
    </test-fixture>

    <test-fixture id="Manual">
      <template>
        <api-view-model-transformer manual-model></api-view-model-transformer>
      </template>
    </test-fixture>
    <script>
    /* global AmfLoader */

    function computeHeaders(element, amf, endpointIndex) {
      const ns = ApiElements.Amf.ns;
      const webApi = element._computeWebApi(amf);
      const endpoints = element._computeEndpoints(webApi);
      const endpoint = endpoints[endpointIndex];
      const opKey = element._getAmfKey(ns.w3.hydra.supportedOperation);
      const operation = element._ensureArray(endpoint[opKey])[0];
      const expects = element._computeExpects(operation);
      const hKey = element._getAmfKey(ns.raml.vocabularies.http + 'header');
      return element._ensureArray(expects[hKey]);
    }
    [
      ['Regular model', false],
      ['Compact model', true]
    ].forEach((item) => {
      suite(item[0], () => {
        suite('Model for headers', () => {
          let amf;
          suiteSetup(() => {
            return AmfLoader.load(item[1])
            .then((data) => {
              amf = data;
            });
          });

          suite('computeViewModel()', () => {
            let model;
            let element;
            setup(() => {
              element = fixture('Basic');
              element.clearCache();
              element.amfModel = amf;
              model = computeHeaders(element, amf, 3);
            });

            test('Returns an array', () => {
              const result = element.computeViewModel(model);
              assert.typeOf(result, 'array');
            });

            test('Has 3 items', () => {
              const result = element.computeViewModel(model);
              assert.lengthOf(result, 3);
            });

            test('Item #1 has all defined properties', () => {
              const result = element.computeViewModel(model.slice(0, 1));
              const header = result[0];
              assert.equal(header.binding, 'header', 'Binding is set');
              assert.notEqual(header.description.indexOf('The application id used'), -1, 'Description is set');
              assert.isTrue(header.hasDescription, 'hasDescription is set');
              assert.equal(header.name, 'x-client-id', 'Name is set');
              assert.isTrue(header.required, 'Required is set');
              assert.equal(header.value, '123456-acme.client.com', 'Default value is set');
              assert.typeOf(header.schema, 'object', 'Schema is set');
              const schema = header.schema;
              assert.isUndefined(schema.defaultValue, 'defaultValue is undefined');
              assert.isTrue(schema.enabled, 'Is enabled');
              assert.isUndefined(schema.enum, 'enum is undefined');
              assert.typeOf(schema.examples, 'array', 'Examples are set');
              assert.lengthOf(schema.examples, 1, 'Examples has 1 item');
              const example = schema.examples[0];
              assert.isFalse(example.hasName, 'example.hasName is false');
              assert.isUndefined(example.name, 'example.name is undefined');
              assert.equal(example.value, '123456-acme.client.com', 'example.value is set');
              assert.equal(schema.inputPlaceholder, 'Example: 123456-acme.client.com', 'inputPlaceholder is set');
              // When placeholder is set
              assert.isTrue(schema.inputFloatLabel, 'inputFloatLabel is true');
              assert.equal(schema.inputLabel, 'x-client-id*', 'inputLabel is set and required');
              assert.equal(schema.inputType, 'text', 'inputType is set');
              assert.isFalse(schema.isArray, 'is not isArray');
              assert.isFalse(schema.isBool, 'is not isBool');
              assert.isFalse(schema.isEnum, 'is not isEnum');
              assert.isFalse(schema.isObject, 'is not isObject');
              assert.isUndefined(schema.items, 'items is undefined');
              assert.isUndefined(schema.maxLength, 'maxLength is undefined');
              assert.isUndefined(schema.maximum, 'maximum is undefined');
              assert.isUndefined(schema.minLength, 'minLength is undefined');
              assert.isUndefined(schema.minimum, 'minimum is undefined');
              assert.isUndefined(schema.multipleOf, 'multipleOf is undefined');
              assert.isUndefined(schema.pattern, 'pattern is undefined');
              assert.equal(schema.type, 'string', 'type is set');
            });

            test('Item #2 has all defined properties', () => {
              const result = element.computeViewModel(model.slice(1, 2));
              const header = result[0];
              assert.equal(header.binding, 'header', 'Binding is set');
              assert.notEqual(header.description.indexOf('People'), -1, 'Description is set');
              assert.isTrue(header.hasDescription, 'hasDescription is set');
              assert.equal(header.name, 'x-people-op-id', 'Name is set');
              assert.isTrue(header.required, 'Required is set');
              assert.equal(header.value, '9719fa6f-c666-48e0-a191-290890760b30', 'Default value is set');
              assert.typeOf(header.schema, 'object', 'Schema is set');
              const schema = header.schema;
              assert.isUndefined(schema.defaultValue, 'defaultValue is undefined');
              assert.isTrue(schema.enabled, 'Is enabled');
              assert.isUndefined(schema.enum, 'enum is undefined');
              assert.typeOf(schema.examples, 'array', 'Examples are set');
              assert.lengthOf(schema.examples, 1, 'Examples has 1 item');
              const example = schema.examples[0];
              assert.isFalse(example.hasName, 'example.hasName is false');
              assert.isUndefined(example.name, 'example.name is undefined');
              assert.equal(example.value, '9719fa6f-c666-48e0-a191-290890760b30', 'example.value is set');
              assert.equal(schema.inputPlaceholder, 'Example: 9719fa6f-c666-48e0-a191-290890760b30', 'inputPlaceholder is set');
              // When placeholder is set
              assert.isTrue(schema.inputFloatLabel, 'inputFloatLabel is true');
              assert.equal(schema.inputLabel, 'x-people-op-id*', 'inputLabel is set and required');
              assert.equal(schema.inputType, 'text', 'inputType is set');
              assert.isFalse(schema.isArray, 'is not isArray');
              assert.isFalse(schema.isBool, 'is not isBool');
              assert.isFalse(schema.isEnum, 'is not isEnum');
              assert.isFalse(schema.isObject, 'is not isObject');
              assert.isUndefined(schema.items, 'items is undefined');
              assert.isUndefined(schema.maxLength, 'maxLength is undefined');
              assert.isUndefined(schema.maximum, 'maximum is undefined');
              assert.isUndefined(schema.minLength, 'minLength is undefined');
              assert.isUndefined(schema.minimum, 'minimum is undefined');
              assert.isUndefined(schema.multipleOf, 'multipleOf is undefined');
              assert.equal(schema.pattern, '^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[4][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$', 'pattern is set');
              assert.equal(schema.type, 'string', 'type is set');
            });

            test('Item #3 has all defined properties', () => {
              const result = element.computeViewModel(model.slice(2, 3));
              const header = result[0];
              assert.equal(header.binding, 'header', 'Binding is set');
              assert.isUndefined(header.description, 'Description is undefined');
              assert.isFalse(header.hasDescription, 'hasDescription is set');
              assert.equal(header.name, 'x-enum', 'Name is set');
              assert.isTrue(header.required, 'Required is set');
              assert.equal(header.value, 'a', 'value is set');
              assert.typeOf(header.schema, 'object', 'Schema is set');
              const schema = header.schema;
              assert.isUndefined(schema.defaultValue, 'defaultValue is undefined');
              assert.isTrue(schema.enabled, 'Is enabled');
              assert.typeOf(schema.enum, 'array', 'enum is set');
              assert.lengthOf(schema.enum, 3, 'enum has 3 items');
              assert.deepEqual(schema.enum, ['a', 'b', 'c'], 'enum has model values');
              assert.isUndefined(schema.examples, 'Examples are set');
              assert.isUndefined(schema.inputFloatLabel, 'inputFloatLabel is undefined');
              assert.equal(schema.inputLabel, 'x-enum*', 'inputLabel is set and required');
              assert.equal(schema.inputType, 'text', 'inputType is set');
              assert.isFalse(schema.isArray, 'is not isArray');
              assert.isFalse(schema.isBool, 'is not isBool');
              assert.isTrue(schema.isEnum, 'isEnum eq true');
              assert.isFalse(schema.isObject, 'is not isObject');
              assert.isUndefined(schema.items, 'items is undefined');
              assert.isUndefined(schema.maxLength, 'maxLength is undefined');
              assert.isUndefined(schema.maximum, 'maximum is undefined');
              assert.isUndefined(schema.minLength, 'minLength is undefined');
              assert.isUndefined(schema.minimum, 'minimum is undefined');
              assert.isUndefined(schema.multipleOf, 'multipleOf is undefined');
              assert.isUndefined(schema.pattern, 'pattern is set');
              assert.equal(schema.type, 'string', 'type is set');
            });
          });

          suite('Nil values', () => {
            let model;
            let element;
            setup(() => {
              element = fixture('Basic');
              element.clearCache();
              element.amfModel = amf;
              model = computeHeaders(element, amf, 2);
            });

            test('Nil value is set', () => {
              const result = element.computeViewModel(model.slice(1, 2));
              assert.equal(result[0].value, 'nil');
            });

            test('Item is read only', () => {
              const result = element.computeViewModel(model.slice(1, 2));
              assert.isTrue(result[0].schema.readOnly);
            });
          });
        });

        suite('Query parameters model', () => {
          let amf;
          suiteSetup(() => {
            return AmfLoader.load(item[0])
            .then((data) => {
              amf = data;
            });
          });

          suite('computeViewModel()', () => {
            let model;
            let element;
            setup(() => {
              element = fixture('Basic');
              element.clearCache();
              element.amfModel = amf;
              const ns = ApiElements.Amf.ns;
              const webApi = element._computeWebApi(amf);
              const endpoints = element._computeEndpoints(webApi);
              const endpoint = endpoints[0];
              const opKey = element._getAmfKey(ns.w3.hydra.supportedOperation);
              const operation = element._ensureArray(endpoint[opKey])[0];
              const expects = element._computeExpects(operation);
              const pKey = element._getAmfKey(ns.raml.vocabularies.http + 'parameter');
              model = element._ensureArray(expects[pKey]);
            });

            test('Resolves to an array', () => {
              const result = element.computeViewModel(model);
              assert.typeOf(result, 'array');
            });

            test('Has 3 items', () => {
              const result = element.computeViewModel(model);
              assert.lengthOf(result, 3);
            });

            test('Has computed data for #1', () => {
              const result = element.computeViewModel(model.slice(0, 1));
              const item = result[0];
              assert.equal(item.binding, 'query', 'Binding is set');
              assert.isUndefined(item.description, 'Description is not set');
              assert.isFalse(item.hasDescription, 'hasDescription is set');
              assert.equal(item.name, 'testRepeatable', 'Name is set');
              assert.isTrue(item.required, 'Required is set');
              assert.typeOf(item.value, 'array', 'Value is an array');

              assert.typeOf(item.schema, 'object', 'Schema is set');
              const schema = item.schema;
              assert.isUndefined(schema.defaultValue, 'defaultValue is undefined');
              assert.isTrue(schema.enabled, 'Is enabled');
              assert.isUndefined(schema.enum, 'enum is undefined');
              assert.typeOf(schema.examples, 'array', 'Examples are set');
              assert.lengthOf(schema.examples, 1, 'Examples has 1 item');
              const example = schema.examples[0];
              assert.isFalse(example.hasName, 'example.hasName is false');
              assert.isUndefined(example.name, 'example.name is undefined');
              assert.equal(example.value, '[\n  "value1",\n  "value2"\n]', 'example.value is set');
              assert.equal(schema.inputPlaceholder, 'Example: [\n  "value1",\n  "value2"\n]', 'inputPlaceholder is set');
              assert.isTrue(schema.inputFloatLabel, 'inputFloatLabel is true');
              assert.equal(schema.inputLabel, 'testRepeatable*', 'inputLabel is set and required');
              assert.equal(schema.inputType, 'text', 'inputType is set');
              assert.isTrue(schema.isArray, 'isArray is true');
              assert.isFalse(schema.isBool, 'is not isBool');
              assert.isFalse(schema.isEnum, 'is not isEnum');
              assert.isFalse(schema.isObject, 'is not isObject');
              assert.equal(schema.items, 'string', 'items is set');
              assert.isUndefined(schema.maxLength, 'maxLength is undefined');
              assert.isUndefined(schema.maximum, 'maximum is undefined');
              assert.isUndefined(schema.minLength, 'minLength is undefined');
              assert.isUndefined(schema.minimum, 'minimum is undefined');
              assert.isUndefined(schema.multipleOf, 'multipleOf is undefined');
              assert.isUndefined(schema.pattern, 'pattern is undefined');
              assert.equal(schema.type, 'array', 'type is set');
            });

            test('Has computed data for #2', () => {
              const result = element.computeViewModel(model.slice(1, 2));
              const item = result[0];
              assert.equal(item.binding, 'query', 'Binding is set');
              assert.isUndefined(item.description, 'Description is not set');
              assert.isFalse(item.hasDescription, 'hasDescription is set');
              assert.equal(item.name, 'numericRepeatable', 'Name is set');
              assert.isTrue(item.required, 'Required is set');
              assert.typeOf(item.value, 'array', 'Value is an array');
              assert.deepEqual(item.value, [123, 456], 'Value is set');

              assert.typeOf(item.schema, 'object', 'Schema is set');
              const schema = item.schema;
              assert.isUndefined(schema.defaultValue, 'defaultValue is undefined');
              assert.isTrue(schema.enabled, 'Is enabled');
              assert.isUndefined(schema.enum, 'enum is undefined');
              assert.typeOf(schema.examples, 'array', 'Examples are set');
              assert.lengthOf(schema.examples, 2, 'Examples has 2 items');

              const example1 = schema.examples[0];
              assert.isTrue(example1.hasName, 'example.hasName is true');
              assert.equal(example1.name, 'Some-test-example', 'example.name is undefined');
              assert.equal(example1.value, '[123, 456]', 'example.value is set'); // <----- THIS IS WRONG!

              const example2 = schema.examples[1];
              assert.isTrue(example2.hasName, 'example2.hasName is true');
              assert.equal(example2.name, 'Other-example', 'example2.name is undefined');
              assert.equal(example2.value, '[1011, 1213]', 'example2.value is set'); // <----- THIS IS WRONG!

              assert.equal(schema.inputPlaceholder,
                'Example: [123, 456]', 'inputPlaceholder is set'); // <----- THIS IS WRONG! is it?
              assert.isTrue(schema.inputFloatLabel, 'inputFloatLabel is true');
              assert.equal(schema.inputLabel, 'numericRepeatable*', 'inputLabel is set and required');
              assert.equal(schema.inputType, 'number', 'inputType is set');
              assert.isTrue(schema.isArray, 'isArray is true');
              assert.isFalse(schema.isBool, 'is not isBool');
              assert.isFalse(schema.isEnum, 'is not isEnum');
              assert.isFalse(schema.isObject, 'is not isObject');
              assert.equal(schema.items, 'integer', 'items is set');
              assert.isUndefined(schema.maxLength, 'maxLength is undefined');
              assert.isUndefined(schema.maximum, 'maximum is undefined');
              assert.isUndefined(schema.minLength, 'minLength is undefined');
              assert.isUndefined(schema.minimum, 'minimum is undefined');
              assert.isUndefined(schema.multipleOf, 'multipleOf is undefined');
              assert.isUndefined(schema.pattern, 'pattern is undefined');
              assert.equal(schema.type, 'array', 'type is set');
            });

            test('Has computed data for #3', () => {
              const result = element.computeViewModel(model.slice(2));
              const item = result[0];
              assert.equal(item.binding, 'query', 'Binding is set');
              assert.isUndefined(item.description, 'Description is not set');
              assert.isFalse(item.hasDescription, 'hasDescription is set');
              assert.equal(item.name, 'notRequiredRepeatable', 'Name is set');
              assert.isFalse(item.required, 'Required is set');
              assert.typeOf(item.value, 'array', 'Value is an array');
              assert.deepEqual(item.value, [''], 'Value is set');

              assert.typeOf(item.schema, 'object', 'Schema is set');
              const schema = item.schema;
              assert.isUndefined(schema.defaultValue, 'defaultValue is undefined');
              assert.isTrue(schema.enabled, 'Is enabled');
              assert.isUndefined(schema.enum, 'enum is undefined');
              assert.isUndefined(schema.examples, 'array', 'Examples are undefined');

              assert.isUndefined(schema.inputPlaceholder, 'inputPlaceholder is not set');
              assert.isUndefined(schema.inputFloatLabel, 'inputFloatLabel is undefined');
              assert.equal(schema.inputLabel, 'notRequiredRepeatable', 'inputLabel is set and not required');
              assert.equal(schema.inputType, 'date', 'inputType is set');
              assert.isTrue(schema.isArray, 'isArray is true');
              assert.isFalse(schema.isBool, 'is not isBool');
              assert.isFalse(schema.isEnum, 'is not isEnum');
              assert.isFalse(schema.isObject, 'is not isObject');
              assert.equal(schema.items, 'date', 'items is set');
              assert.isUndefined(schema.maxLength, 'maxLength is undefined');
              assert.isUndefined(schema.maximum, 'maximum is undefined');
              assert.isUndefined(schema.minLength, 'minLength is undefined');
              assert.isUndefined(schema.minimum, 'minimum is undefined');
              assert.isUndefined(schema.multipleOf, 'multipleOf is undefined');
              assert.isUndefined(schema.pattern, 'pattern is undefined');
              assert.equal(schema.type, 'array', 'type is set');
            });
          });

          suite('Nil values', () => {
            let model;
            let element;
            setup(() => {
              element = fixture('Basic');
              element.clearCache();
              element.amfModel = amf;
              const ns = ApiElements.Amf.ns;
              const webApi = element._computeWebApi(amf);
              const endpoints = element._computeEndpoints(webApi);
              const endpoint = endpoints[2];
              const opKey = element._getAmfKey(ns.w3.hydra.supportedOperation);
              const operation = element._ensureArray(endpoint[opKey])[0];
              const expects = element._computeExpects(operation);
              const pKey = element._getAmfKey(ns.raml.vocabularies.http + 'parameter');
              model = element._ensureArray(expects[pKey]);
            });

            test('Nil value is set', () => {
              const result = element.computeViewModel(model.slice(0, 1));
              assert.equal(result[0].value, 'nil');
            });

            test('Item is read only', () => {
              const result = element.computeViewModel(model.slice(0, 1));
              assert.isTrue(result[0].schema.readOnly);
            });
          });

          suite('Default values', () => {
            let model;
            let element;
            setup(() => {
              element = fixture('Basic');
              element.clearCache();
              element.amfModel = amf;
              model = computeHeaders(element, amf, 12);
            });

            test('Computes string default value', () => {
              const result = element.computeViewModel(model.slice(0, 1));
              assert.strictEqual(result[0].schema.defaultValue, 'TestDefault');
              assert.strictEqual(result[0].value, result[0].schema.defaultValue);
            });

            test('Computes number default value', () => {
              const result = element.computeViewModel(model.slice(1, 2));
              assert.strictEqual(result[0].schema.defaultValue, 1234);
              assert.strictEqual(result[0].value, result[0].schema.defaultValue);
            });

            test('Computes boolean default value', () => {
              const result = element.computeViewModel(model.slice(2, 3));
              assert.strictEqual(result[0].schema.defaultValue, false);
              assert.strictEqual(result[0].value, 'false');
            });

            test('Computes array default value', () => {
              const result = element.computeViewModel(model.slice(3, 4));
              assert.deepEqual(result[0].schema.defaultValue, ['ArrayTest', 'OtherTest']);
              assert.deepEqual(result[0].value, result[0].schema.defaultValue);
            });
          });
        });

        suite('Path parameters model', () => {
          let amf;
          suiteSetup(() => {
            return AmfLoader.load(item[0])
            .then((data) => {
              amf = data;
            });
          });

          suite('computeViewModel()', () => {
            let model;
            let element;
            setup(() => {
              element = fixture('Basic');
              element.clearCache();
              element.amfModel = amf;
              const ns = ApiElements.Amf.ns;
              const webApi = element._computeWebApi(amf);
              const endpoints = element._computeEndpoints(webApi);
              const endpoint = endpoints[0];
              const pKey = element._getAmfKey(ns.raml.vocabularies.http + 'parameter');
              model = element._ensureArray(endpoint[pKey]);
            });

            test('Resolves to an array', () => {
              const result = element.computeViewModel(model);
              assert.typeOf(result, 'array');
            });

            test('Has 1 item', () => {
              const result = element.computeViewModel(model);
              assert.lengthOf(result, 1);
            });

            test('Has computed data', () => {
              const result = element.computeViewModel(model);
              const item = result[0];
              assert.equal(item.binding, 'path', 'Binding is set');
              assert.isUndefined(item.description, 'Description is not set');
              assert.isFalse(item.hasDescription, 'hasDescription is set');
              assert.equal(item.name, 'feature', 'Name is set');
              assert.isTrue(item.required, 'Required is set');
              assert.equal(item.value, 'A', 'Value is set');

              assert.typeOf(item.schema, 'object', 'Schema is set');
              const schema = item.schema;
              assert.isUndefined(schema.defaultValue, 'defaultValue is undefined');
              assert.isTrue(schema.enabled, 'Is enabled');
              assert.typeOf(schema.enum, 'array', 'enum is set');
              assert.deepEqual(schema.enum, ['A', 'B', 'C'], 'enum values are set');
              assert.isUndefined(schema.examples, 'array', 'Examples is undefined');
              assert.isUndefined(schema.inputPlaceholder, 'inputPlaceholder is not set');
              assert.isUndefined(schema.inputFloatLabel, 'inputFloatLabel is undefined');
              assert.equal(schema.inputLabel, 'feature*', 'inputLabel is set and required');
              assert.equal(schema.inputType, 'text', 'inputType is set');
              assert.isFalse(schema.isArray, 'isArray is true');
              assert.isFalse(schema.isBool, 'is not isBool');
              assert.isTrue(schema.isEnum, 'is not isEnum');
              assert.isFalse(schema.isObject, 'is not isObject');
              assert.isUndefined(schema.items, 'string', 'items is set');
              assert.isUndefined(schema.maxLength, 'maxLength is undefined');
              assert.isUndefined(schema.maximum, 'maximum is undefined');
              assert.isUndefined(schema.minLength, 'minLength is undefined');
              assert.isUndefined(schema.minimum, 'minimum is undefined');
              assert.isUndefined(schema.multipleOf, 'multipleOf is undefined');
              assert.isUndefined(schema.pattern, 'pattern is undefined');
              assert.equal(schema.type, 'string', 'type is set');
            });
          });
        });

        suite('Date formats', () => {
          let amf;
          suiteSetup(() => {
            return AmfLoader.load(item[1])
            .then((data) => {
              amf = data;
            });
          });

          let model;
          let element;
          setup(() => {
            element = fixture('Basic');
            element.clearCache();
            element.amfModel = amf;
            model = computeHeaders(element, amf, 13);
          });

          test('Has pattern for "time" type', () => {
            const result = element.computeViewModel(model);
            const item = result[1];
            assert.equal(item.schema.pattern, '^[0-9]{2}:[0-9]{2}:[0-9]{2}\.?[0-9]{0,3}$');
          });

          test('Format for "time" type is undefined', () => {
            const result = element.computeViewModel(model);
            const item = result[1];
            assert.isUndefined(item.schema.format);
          });

          test('Placeholder for "time" type is set', () => {
            const result = element.computeViewModel(model);
            const item = result[1];
            assert.equal(item.schema.inputPlaceholder, '00:00:00.000');
          });

          test('Has pattern for "date" type', () => {
            const result = element.computeViewModel(model);
            const item = result[0];
            assert.equal(item.schema.pattern, '^[0-9]{4}-[0-9]{2}-[0-9]{2}$');
          });

          test('Format for "date" type is undefined', () => {
            const result = element.computeViewModel(model);
            const item = result[0];
            assert.isUndefined(item.schema.format);
          });

          test('Placeholder for "date" type is set', () => {
            const result = element.computeViewModel(model);
            const item = result[0];
            assert.equal(item.schema.inputPlaceholder, '0000-00-00');
          });

          test('Has pattern for "datetime-only" type', () => {
            const result = element.computeViewModel(model);
            const item = result[2];
            assert.equal(item.schema.pattern, '^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}\.?[0-9]{0,3}$');
          });

          test('Format for "datetime-only" type is undefined', () => {
            const result = element.computeViewModel(model);
            const item = result[2];
            assert.isUndefined(item.schema.format);
          });

          test('Placeholder for "datetime-only" type is set', () => {
            const result = element.computeViewModel(model);
            const item = result[2];
            assert.equal(item.schema.inputPlaceholder, '0000-00-00T00:00:00.000');
          });

          test('Has pattern for "datetime" type, default format', () => {
            const result = element.computeViewModel(model);
            const item = result[3];
            assert.equal(item.schema.pattern, '^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}.*$');
          });

          test('Format for "datetime" type, default format is undefined', () => {
            const result = element.computeViewModel(model);
            const item = result[3];
            assert.isUndefined(item.schema.format);
          });

          test('Placeholder for "datetime" type, default format is set', () => {
            const result = element.computeViewModel(model);
            const item = result[3];
            assert.equal(item.schema.inputPlaceholder, '0000-00-00T00:00:00Z+01:00');
          });

          test('Has pattern for "datetime" type, rfc3339 format', () => {
            const result = element.computeViewModel(model);
            const item = result[4];
            assert.equal(item.schema.pattern, '^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}.*$');
          });

          test('Format for "datetime" type, rfc3339 format is set', () => {
            const result = element.computeViewModel(model);
            const item = result[4];
            assert.equal(item.schema.format, 'rfc3339');
          });

          test('Placeholder for "datetime" type, rfc3339 format is set', () => {
            const result = element.computeViewModel(model);
            const item = result[4];
            assert.equal(item.schema.inputPlaceholder, '0000-00-00T00:00:00Z+01:00');
          });

          test('Has no pattern for "datetime" type, rfc2616 format', () => {
            const result = element.computeViewModel(model);
            const item = result[5];
            assert.equal(item.schema.pattern, '');
          });

          test('Format for "datetime" type, rfc2616 format is set', () => {
            const result = element.computeViewModel(model);
            const item = result[5];
            assert.equal(item.schema.format, 'rfc2616');
          });

          test('Placeholder for "datetime" type, rfc2616 format is set', () => {
            const result = element.computeViewModel(model);
            const item = result[5];
            assert.equal(item.schema.inputPlaceholder, 'Sun, 01 Jan 2000 00:00:00 GMT');
          });
        });

        suite('computeViewModel()', () => {
          let amf;
          suiteSetup(() => {
            return AmfLoader.load(item[1])
            .then((data) => {
              amf = data;
            });
          });

          let model;
          let element;
          setup(() => {
            element = fixture('Manual');
            element.amfModel = amf;
            model = computeHeaders(element, amf, 13);
          });

          test('Clears viewModel property', () => {
            element._setViewModel('TEST');
            element.computeViewModel();
            assert.isUndefined(element.viewModel);
          });

          test('Uses "shape" property when not provided', () => {
            element.shape = model;
            const result = element.computeViewModel();
            assert.typeOf(result, 'array');
          });

          test('Returns undefined when no shape', () => {
            const result = element.computeViewModel();
            assert.isUndefined(result);
          });

          test('Makes a copy of the array', () => {
            const result = element.computeViewModel(model);
            model.push('test');
            assert.notEqual(result.length, model.length);
          });

          test('Sets viewModel property', () => {
            const result = element.computeViewModel(model);
            assert.isTrue(result === element.viewModel);
          });
        });

        suite('_computeViewModel()', () => {
          let amf;
          suiteSetup(() => {
            return AmfLoader.load(item[1])
            .then((data) => {
              amf = data;
            });
          });

          let element;
          setup(() => {
            element = fixture('Manual');
            element.amfModel = amf;
          });

          test('Returns empty array when no argument', () => {
            const result = element._computeViewModel();
            assert.typeOf(result, 'array');
            assert.lengthOf(result, 0);
          });

          test('Returns empty array when argument is empty array', () => {
            const result = element._computeViewModel([]);
            assert.typeOf(result, 'array');
            assert.lengthOf(result, 0);
          });

          test('Returns empty array when argument is invalid object', () => {
            const result = element._computeViewModel({});
            assert.typeOf(result, 'array');
            assert.lengthOf(result, 0);
          });

          test('Retuns model for RAW type.', () => {
            const refs = element._computeReferences(amf);
            const r = refs[13];
            const enc = element._ensureArray(element._computeEncodes(r));
            const key = element._getAmfKey(element.ns.raml.vocabularies.document + 'dataNode');
            const model = element._ensureArray(enc[0][key])[0];
            const result = element._computeViewModel(model);
            assert.typeOf(result, 'array');
            assert.lengthOf(result, 1);
          });

          test('Do not returns invalid definitions', () => {
            const result = element._computeViewModel([{}]);
            assert.typeOf(result, 'array');
            assert.lengthOf(result, 0);
          });

          test('Returns valid definitions', () => {
            const model = computeHeaders(element, amf, 13);
            const result = element._computeViewModel(model);
            assert.typeOf(result, 'array');
            assert.lengthOf(result, 6);
          });
        });

        function computePropertyShape(element, amf, declareIndex) {
          const decs = element._computeDeclares(amf);
          let dec = decs[declareIndex];
          if (dec instanceof Array) {
            dec = dec[0];
          }
          if (element._hasType(dec, ApiElements.Amf.ns.raml.vocabularies.shapes + 'ScalarShape')) {
            return dec;
          }
          const key = element._getAmfKey(ApiElements.Amf.ns.w3.shacl.name + 'property');
          return element._ensureArray(dec[key]);
        }

        suite('uiModelForAmfItem()', () => {
          let amf;
          suiteSetup(() => {
            return AmfLoader.load(item[1])
            .then((data) => {
              amf = data;
            });
          });

          let element;
          setup(() => {
            element = fixture('Manual');
            element.amfModel = amf;
          });

          test('Returns undefined when type is not suppoerted', () => {
            const result = element.uiModelForAmfItem({});
            assert.isUndefined(result);
          });

          test('Returns model for http#Parameter', () => {
            const model = computeHeaders(element, amf, 3)[0];
            const result = element.uiModelForAmfItem(model);
            assert.typeOf(result, 'object');
          });

          test('Returns model for shacl#PropertyShape', () => {
            const model = computePropertyShape(element, amf, 3);
            const result = element.uiModelForAmfItem(model[0]);
            assert.typeOf(result, 'object');
          });
        });

        suite('_uiModelForPropertyShape()', () => {
          let amf;
          suiteSetup(() => {
            return AmfLoader.load(item[1])
            .then((data) => {
              amf = data;
            });
          });

          let element;
          setup(() => {
            element = fixture('Manual');
            element.clearCache();
            element.amfModel = amf;
          });

          test('Returns an object', () => {
            const model = computePropertyShape(element, amf, 3);
            const result = element._uiModelForPropertyShape(model[0]);
            assert.typeOf(result, 'object');
          });

          test('Result\'s binding is "type"', () => {
            const model = computePropertyShape(element, amf, 3);
            const result = element._uiModelForPropertyShape(model[0]);
            assert.equal(result.binding, 'type');
          });

          test('Computes name property', () => {
            const model = computePropertyShape(element, amf, 3);
            const result = element._uiModelForPropertyShape(model[0]);
            assert.equal(result.name, 'error');
          });

          test('Has name and binding only when no range', () => {
            const model = Object.assign({}, computePropertyShape(element, amf, 3)[0]);
            const key = element._getAmfKey(ApiElements.Amf.ns.raml.vocabularies.shapes + 'range');
            delete model[key];
            const result = element._uiModelForPropertyShape(model);
            assert.typeOf(result.name, 'string');
            assert.typeOf(result.binding, 'string');
            assert.lengthOf(Object.keys(result), 2);
          });

          test('required is computed', () => {
            const model = computePropertyShape(element, amf, 3)[0];
            const result = element._uiModelForPropertyShape(model);
            assert.isTrue(result.required);
          });

          test('Schema is set', () => {
            const model = computePropertyShape(element, amf, 3)[0];
            const result = element._uiModelForPropertyShape(model);
            assert.typeOf(result.schema, 'object');
          });

          test('schema.enabled is always true', () => {
            const model = computePropertyShape(element, amf, 3)[0];
            const result = element._uiModelForPropertyShape(model);
            assert.isTrue(result.schema.enabled);
          });

          test('schema.type is computed', () => {
            const model = computePropertyShape(element, amf, 3)[0];
            const result = element._uiModelForPropertyShape(model);
            assert.equal(result.schema.type, 'boolean');
          });

          test('schema.isEnum is false when no enum', () => {
            const model = computePropertyShape(element, amf, 3)[0];
            const result = element._uiModelForPropertyShape(model);
            assert.isFalse(result.schema.isEnum);
          });

          test('schema.isEnum is true if enum value', () => {
            const model = computePropertyShape(element, amf, 10);
            const result = element._uiModelForPropertyShape(model);
            assert.isTrue(result.schema.isEnum);
          });

          test('schema.inputLabel is computed', () => {
            const model = computePropertyShape(element, amf, 3)[0];
            const result = element._uiModelForPropertyShape(model);
            assert.equal(result.schema.inputLabel, 'error*');
          });

          test('schema.pattern is undefined when missing', () => {
            const model = computePropertyShape(element, amf, 3)[0];
            const result = element._uiModelForPropertyShape(model);
            assert.isUndefined(result.schema.pattern);
          });

          test('schema.pattern is computed', () => {
            const model = computePropertyShape(element, amf, 5)[2];
            const result = element._uiModelForPropertyShape(model);
            assert.equal(result.schema.pattern, '^[0-9a-zA-Z ]+$');
          });

          test('schema.minLength is undefined when missing', () => {
            const model = computePropertyShape(element, amf, 3)[0];
            const result = element._uiModelForPropertyShape(model);
            assert.isUndefined(result.schema.minLength);
          });

          test('schema.maxLength is undefined when missing', () => {
            const model = computePropertyShape(element, amf, 3)[0];
            const result = element._uiModelForPropertyShape(model);
            assert.isUndefined(result.schema.maxLength);
          });

          test('schema.minLength is set', () => {
            const model = computePropertyShape(element, amf, 7);
            const result = element._uiModelForPropertyShape(model);
            assert.equal(result.schema.minLength, 10);
          });

          test('schema.maxLength is set', () => {
            const model = computePropertyShape(element, amf, 7);
            const result = element._uiModelForPropertyShape(model);
            assert.equal(result.schema.maxLength, 20);
          });

          test('schema.defaultValue is computed', () => {
            const model = computePropertyShape(element, amf, 3)[0];
            const result = element._uiModelForPropertyShape(model);
            assert.isTrue(result.schema.defaultValue);
          });

          test('schema.defaultValue is undefined when missing', () => {
            const model = computePropertyShape(element, amf, 3)[1];
            const result = element._uiModelForPropertyShape(model);
            assert.isUndefined(result.schema.defaultValue);
          });

          test('schema.minimum is computed', () => {
            const model = computePropertyShape(element, amf, 4);
            const result = element._uiModelForPropertyShape(model);
            assert.equal(result.schema.minimum, 2.0);
          });

          test('schema.minimum is undefined when missing', () => {
            const model = computePropertyShape(element, amf, 3)[1];
            const result = element._uiModelForPropertyShape(model);
            assert.isUndefined(result.schema.minimum);
          });

          test('schema.maximum is computed', () => {
            const model = computePropertyShape(element, amf, 4);
            const result = element._uiModelForPropertyShape(model);
            assert.equal(result.schema.maximum, 12.0);
          });

          test('schema.maximum is undefined when missing', () => {
            const model = computePropertyShape(element, amf, 3)[1];
            const result = element._uiModelForPropertyShape(model);
            assert.isUndefined(result.schema.maximum);
          });

          test('description is computed', () => {
            const model = computePropertyShape(element, amf, 8)[1];
            const result = element._uiModelForPropertyShape(model);
            assert.typeOf(result.description, 'string');
          });

          test('hasDescription is true when has description', () => {
            const model = computePropertyShape(element, amf, 8)[1];
            const result = element._uiModelForPropertyShape(model);
            assert.isTrue(result.hasDescription);
          });

          test('description is undefined when missing', () => {
            const model = computePropertyShape(element, amf, 4);
            const result = element._uiModelForPropertyShape(model);
            assert.isUndefined(result.description);
          });

          test('hasDescription is false when no description', () => {
            const model = computePropertyShape(element, amf, 4);
            const result = element._uiModelForPropertyShape(model);
            assert.isFalse(result.hasDescription);
          });

          test('description is undefined when noDocs is set', () => {
            element.noDocs = true;
            const model = computePropertyShape(element, amf, 8)[1];
            const result = element._uiModelForPropertyShape(model);
            assert.isUndefined(result.description);
          });

          test('hasDescription is false when noDocs is set', () => {
            element.noDocs = true;
            const model = computePropertyShape(element, amf, 8)[1];
            const result = element._uiModelForPropertyShape(model);
            assert.isFalse(result.hasDescription);
          });
        });

        suite('Nillable union', () => {
          let amf;
          suiteSetup(() => {
            return AmfLoader.load(item[1])
            .then((data) => {
              amf = data;
            });
          });

          let element;
          let model;
          setup(() => {
            element = fixture('Manual');
            element.clearCache();
            element.amfModel = amf;
            model = computeHeaders(element, amf, 14);
          });

          test('Sets "isNillable" property', () => {
            const result = element.computeViewModel(model);
            const item = result[0];
            assert.isTrue(item.schema.isNillable);
          });

          test('"isNillable" is false when no union', () => {
            const result = element.computeViewModel(model);
            const item = result[1];
            assert.isFalse(item.schema.isNillable);
          });

          test('"isNillable" is false when other scalar', () => {
            const result = element.computeViewModel(model);
            const item = result[2];
            assert.isFalse(item.schema.isNillable);
          });

          test('"isNillable" is false when union without nil', () => {
            const result = element.computeViewModel(model);
            const item = result[3];
            assert.isFalse(item.schema.isNillable);
          });
        });
      });
    });
    </script>
  </body>
</html>

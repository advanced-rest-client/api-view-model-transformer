<!-- <link rel="import" href="jsonld-import.html"> -->
<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../events-target-behavior/events-target-behavior.html">
<link rel="import" href="jsonld-import.html">

<script>
(function() {
'use strict';
/**
 * @license
 * Copyright 2016 The Advanced REST client authors <arc@mulesoft.com>
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
const NUMBER_INPUT_TYPES = ['number', 'integer', 'float'];
const RAML_V_HTTP = 'http://raml.org/vocabularies/http';
const RAML_V_SHAPES = 'http://raml.org/vocabularies/shapes';
const RAML_V_DOC = 'http://raml.org/vocabularies/document';
const HYDRA_CORE = 'http://www.w3.org/ns/hydra/core';
const SCHEMA = 'http://schema.org/';
const SHACL = 'http://www.w3.org/ns/shacl';
const RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns';
const ARRAY_SHAPE = RAML_V_SHAPES + '#ArrayShape';
const XML_SCHEMA = 'http://www.w3.org/2001/XMLSchema';
const DATA_VOC = 'http://raml.org/vocabularies/data';
/**
 * An element to transform AMF LD model into a form view model.
 *
 * Note, this element does not include polyfills for `Promise` and `Array.from`.
 *
 * The model should be used to build a form view for request parameters
 * like header, query parameters, uri parameters or the body.
 *
 * ### Data model
 * - binding {String} - one of `path`, `query`, `header`
 * - name {String} - property (form) name
 * - required {Boolean} - is property required
 * - value {any} - Value of the property
 * - description {String} - The description of the property
 * - hasDescription {Boolean} - Flag describing if the property has a
 * description.
 * - schema {Object} - Property schma information
 * - schema.type {String} - Data type of the property
 * - schema.inputLabel {String} Label for the form control
 * - schema.inputType {String} - type attribute of the `input` element.
 * - schema.pattern {String} - Regex pattern of the property
 * - schema.minLength {Number} - String property minimum length
 * - schema.maxLength {Number} - String property maximum length
 * - schema.defaultValue {any} - Default value of the property
 * - schema.examples {Array<Object>} - List of examples for the form property.
 * - schema.multipleOf {Number} - For numeric values, a `step` attribute of
 * the `input` element.
 * Each object may contain `name` (may be undefined) and must contain `value`
 * property of the example.
 * - schema.minimum {Number} - For numeric values, minimum value of the property
 * - schema.maximum {Number} - For numeric values, maximum value of the property
 * - schema.isEnum {Boolean} - Flag describing enumerable value
 * - schema.enum {Array<any>} - Only if `schema.isEnum` is set. Values for enum
 * input.
 * - schema.isArray {Boolean} - Flag describing array value for the property
 * - schema.items {Object} - Lsit of items definitions
 * - schema.isBool {Boolean} - Flag describing boolean value for the property
 * - schema.inputPlaceholder {?String} - A placeholder value for the input.
 * - schema.inputFloatLabel {Boolean} - Only if placeholder is set. Instructs
 * input control to float a label.
 * - schema.isUnion {Boolean} - Flag describing union value
 * - schema.anyOf {Array<Object>} - List of possible types of the union.
 * - schema.enabled {Boolean} - Always `true`
 *
 * ## Example
 *
 * ```html
 * <api-view-model-transformer on-view-model-changed="_updateView"></api-view-model-transformer>
 * <script>
 * const amfModel = getAmfFromRamlOrOas();
 * const processor = document.querySelector('api-view-model-transformer');
 * if (amfModel['@context']) {
 *  processor.amfContext = amfModel['@context'];
 * }
 * processor.amfModel = extractHeadersForMethod(amfModel);
 * processor.addEventListener('view-model-changed', (e) => {
 *  console.log(e.detail.value);
 * });
 * < /script>
 * ```
 *
 * This example uses `getAmfFromRamlOrOas()` function where you implement
 * the logic of getting AMF json/ld data. It can be stored in file or parsed
 * using AMF parsers. The `extractHeadersForMethod()` represents a logic to
 * extract properties that you want to transform. It can be headers, query
 * parameters or body type.
 *
 * ## JSON ld context
 *
 * JSON schema may contain `@context` property. It can be used to reduce size
 * of the schema by replacing namespace ids with defined in `@context` keywords.
 * This transformer does not consume whole AMF model, but only the portion that
 * should be transformed. Because of that the tranformer is missing context
 * for namespace resolving. Set `@context` value of the model to `amfContext`
 * property so it can be expanded to the canonical form.
 * **Tranformation won't work properly if namespace name are altered by context
 * and `amfContext` property is not set.**
 *
 * @extends HTMLElement
 * @customElement
 * @group API Elements
 * @memberof API Elements
 * @element api-view-model-transformer
 * @demo demo/index.html
 * @appliesMixin ArcBehaviors.EventsTargetBehavior
 */
class ApiViewModelTransformer extends ArcBehaviors.EventsTargetBehavior(Polymer.Element) {
  static get is() { return 'api-view-model-transformer'; }
  static get properties() {
    return {
      /**
       * AMF model extracted from RAML or OAS spec and transformed to
       * JSON/LD schema.
       * This is an array of propertues for which view model is generated.
       * It accepts model for headers, query parameters, uri parameters and
       * body.
       * If `manualModel` is not set, assigning a value to this property will
       * trigger model computation. Otherwise call `computeViewModel()`
       * function manually to generate the model.
       */
      amfModel: {
        type: Array,
        observer: '_amfModelChanged'
      },
      /**
       * Generated view model from the `amfModel`
       *
       * @type {Array<Object>}
       */
      viewModel: {
        type: Array,
        notify: true,
        readOnly: true
      },
      /**
       * If set, assigning a value to `amfModel` will not trigger view model
       * computation.
       */
      manualModel: Boolean,
      /**
       * AMF json/ld contect to use to find keys in the model.
       *
       * ### Example
       * ```javascript
       * {
       *  "doc": "http://raml.org/vocabularies/document#",
       *  "shapes": "http://raml.org/vocabularies/shapes#",
       *  "raml-http": "http://raml.org/vocabularies/http#"
       *  }
       * ```
       * This context generate the following keys for the `amfModel`:
       * - `doc:Document` as `http://raml.org/vocabularies/document#Document`
       * - `shapes:NilShape` as `http://raml.org/vocabularies/shapes#NilShape`
       * - `raml-http:Parameter` as `http://raml.org/vocabularies/http#Parameter`
       *
       * Context can be used to reduce model size by shortering namespace
       * declaration. Setting `amfContext` allows this element to propertly
       * read the schema.
       */
      amfContext: Object,
      /**
       * The declarations model for the AMF object. It is used when the
       * transformer attempt to transform link value.
       *
       * If this property is not set then it dispatches `amf-resolve-link`
       * custom event.
       */
      amfDeclarations: Array
    };
  }

  constructor() {
    super();
    this._buildPropertyHandler = this._buildPropertyHandler.bind(this);
  }

  _attachListeners(node) {
    node.addEventListener('api-property-model-build', this._buildPropertyHandler);
  }

  _detachListeners(node) {
    node.removeEventListener('api-property-model-build', this._buildPropertyHandler);
  }
  /**
   * Called when either `amfModel` or `manualModel` propeties changed.
   * If `manualModel` is falsy then it calls `computeViewModel()` function.
   *
   * Note, this function won't be called when sub property of the model
   * change. For peformance rerasons it won't be supported.
   *
   * Note, `computeViewModel` is called asynchronusly so `amfContext`
   * property can be set.
   *
   * @param {Array} amfModel Current AMF model
   */
  _amfModelChanged(amfModel) {
    if (this.manualModel) {
      return;
    }
    setTimeout(() => this.computeViewModel(amfModel, this.amfContext), 2);
  }

  /**
   * Computes view model from AMF data model. This should not be called if
   * `manualModel` is not set. Use `amfModel` property instead.
   *
   * @param {?Array|Object} amfModel AMF type model. If not set it uses `amfModel`
   * property of the element.
   * @param {?Object} amfContext JSON ld schema context. The same as
   * `amfContext` property. Don't set the property on the element when using
   * manual model computation. Instead call this function with context.
   */
  computeViewModel(amfModel, amfContext) {
    this._setViewModel(undefined);
    if (!amfModel) {
      amfModel = this.amfModel;
    }
    if (!amfModel) {
      return Promise.resolve();
    }
    let promise;
    if (!!amfContext) {
      promise = this._expandSchema(amfModel, amfContext);
    } else {
      promise = Promise.resolve(amfModel);
    }
    return promise
    .then((model) => {
      if (model instanceof Array) {
        model = Array.from(model);
      }
      return this._computeViewModelRecursive(model);
    })
    .then((model) => {
      this._setViewModel(model);
      return model;
    });
  }
  /**
   * Conputes model for each item recursively. It allows browser to return
   * the event loop and prohibit ANR to show.
   *
   * @param {Array} items List of remanding AMF model items.
   * This shuld be copy of the model since this function removes items from
   * the list.
   * @param {?Array} result Result of model comupation. It's repoted by
   * the Promise.
   * @return {Promise} Promise resolved to thre view model.
   */
  _computeViewModelRecursive(items, result) {
    result = result || [];
    if (!items) {
      return Promise.resolve(result);
    }
    const isArray = items instanceof Array;
    if (isArray && !items.length) {
      return Promise.resolve(result);
    }
    if (isArray) {
      const item = items.shift();
      const model = this.uiModelForAmfItem(item);
      if (model) {
        result.push(model);
      } else {
        console.warn('Unable to compute view data model for', item);
      }
      return Promise.resolve()
      .then(() => this._computeViewModelRecursive(items, result));
    }
    if (this._modelHasType(items, DATA_VOC + '#Object')) {
      return this.modelForRawObject(items);
    } else {
      return Promise.resolve(result);
    }
  }
  /**
   * Creates a UI model item from AMF json/ld model.
   * @param {Object} amfItem AMF model with schema for
   * `http://raml.org/vocabularies/http#Parameter`
   * @return {Object} UI data model.
   */
  uiModelForAmfItem(amfItem) {
    if (this._modelHasType(amfItem, RAML_V_HTTP + '#Parameter')) {
      return this._uiModelForParameter(amfItem);
    }
    if (this._modelHasType(amfItem, SHACL + '#PropertyShape')) {
      return this._uiModelForPropertyShape(amfItem);
    }
  }
  /**
   * Creates a UI model item from AMF json/ld model for a parameter.
   * @param {Object} amfItem AMF model with schema for
   * `http://raml.org/vocabularies/http#Parameter`
   * @return {Object} UI data model.
   */
  _uiModelForParameter(amfItem) {
    const result = {};
    result.binding = this._computeBinding(amfItem);
    const valueDelimiter = this._computeValueDelimiter(result.binding);
    const decodeValues = this._computeDecodeValues(result.binding);
    result.name = this._computeFormName(amfItem);
    result.description = this._computeDescription(amfItem);
    result.hasDescription = !!result.description;
    result.required = this._computeRequired(amfItem);
    const processOptions = {
      name: result.name,
      required: result.required,
      valueDelimiter: valueDelimiter,
      decodeValues: decodeValues
    };
    result.schema = this._computeParameterSchema(amfItem, processOptions);
    this._processAfterItemCreated(result, processOptions);
    return result;
  }
  /**
   * Creates a UI model item from AMF json/ld model for a parameter.
   * @param {Object} amfItem AMF model with schema for
   * `http://raml.org/vocabularies/http#Parameter`
   * @return {Object} UI data model.
   */
  _uiModelForPropertyShape(amfItem) {
    const result = {};
    result.binding = 'type';
    result.name = this._computeShaclProperty(amfItem, 'name');
    let def = amfItem[RAML_V_SHAPES + '#range'];
    if (!def) {
      return result;
    }
    def = def[0];
    result.description = this._computeDescription(def);
    result.hasDescription = !!result.description;
    result.required = this._computeRequired(def);
    result.schema = {};
    if (result.required === undefined) {
      result.required = false;
    }
    result.schema.enabled = true;
    result.schema.type = this._computeModelType(def);
    result.schema.inputLabel = this._computeInputLabel(def, result.required, result.name);
    result.schema.pattern = this._computeShaclProperty(def, 'pattern');
    result.schema.minLength = this._computeShaclProperty(def, 'minLength');
    result.schema.maxLength = this._computeShaclProperty(def, 'maxLength');
    result.schema.defaultValue = this._computeShaclProperty(def, 'defaultValue');
    result.schema.multipleOf = this._computeVocabularyShapeProperty(def, 'multipleOf');
    result.schema.minimum = this._computeShaclProperty(def, 'minInclusive');
    result.schema.maximum = this._computeShaclProperty(def, 'maxInclusive');
    result.schema.enum = this._computeModelEnum(def);
    result.schema.isEnum = !!result.schema.enum;
    result.schema.isArray = result.schema.type === 'array';
    result.schema.isBool = result.schema.type === 'boolean';
    result.schema.examples = this._computeModelExamples(def);
    result.schema.inputType = this._computeModelInputType(result.schema.type, result.schema.items);
    result.schema.pattern = this._computeModelPattern(result.schema.type, result.schema.pattern);
    this._processAfterItemCreated(result, {});
    return result;
  }
  /**
   * Creates a view model for an object definition. Object definition can be
   * part of trait or annotation properties description.
   *
   * @param {Object} model Model to extract data from.
   * @param {Object} processOptions
   * @return {Array} View model for items.
   */
  modelForRawObject(model, processOptions) {
    if (!processOptions) {
      processOptions = {};
    }
    const result = [];
    const keys = Object.keys(model);
    keys.forEach((key) => {
      if (key.indexOf(DATA_VOC) === -1) {
        return;
      }
      let item = this._uiModelForRawObject(key, model[key][0]);
      if (item) {
        // debugger;
        item = this._processAfterItemCreated(item, processOptions);
        result.push(item);
      }
    });
    return result;
  }
  /**
   * Creates a view model from "raw" item (model before resolving).
   *
   * @param {String} key Key of the item in the model.
   * @param {String} model Item model
   * @return {Object} View model
   */
  _uiModelForRawObject(key, model) {
    const name = key.split('#')[1];
    const result = {};
    result.binding = 'type';
    result.name = name;
    let type = this._computeRawModelValue(model[DATA_VOC + '#type']);
    if (!type) {
      type = 'string';
    }
    let bracetIndex = type.indexOf('[]');
    let items;
    if (bracetIndex !== -1) {
      items = type.substr(0, bracetIndex);
      type = 'array';
    }
    result.description = this._computeRawModelValue(model[DATA_VOC + '#description']);
    result.hasDescription = !!result.description;
    result.required = this._computeRawModelValue(model[DATA_VOC + '#required']);
    result.schema = {};
    result.schema.enabled = true;
    result.schema.type = type || 'string';
    const displayName = this._computeRawModelValue(model[DATA_VOC + '#displayName']);
    result.schema.inputLabel = this._completeInputLabel(displayName, name, result.required);
    result.schema.minLength = this._computeRawModelValue(model[DATA_VOC + 'minLength']);
    result.schema.maxLength = this._computeRawModelValue(model[DATA_VOC + 'maxLength']);
    result.schema.defaultValue = this._computeRawModelValue(model[DATA_VOC + 'default']);
    result.schema.multipleOf = this._computeRawModelValue(model[DATA_VOC + 'multipleOf']);
    result.schema.minimum = this._computeRawModelValue(model[DATA_VOC + 'minimum']);
    result.schema.maximum = this._computeRawModelValue(model[DATA_VOC + 'maximum']);
    result.schema.enum = this._computeRawModelValue(model[DATA_VOC + 'enum']);
    let pattern = this._computeRawModelValue(model[DATA_VOC + '#pattern']);
    if (pattern instanceof Array) {
      pattern = '[' + pattern[0] + ']';
    }
    result.schema.pattern = pattern;
    result.schema.isEnum = !!result.schema.enum;
    result.schema.isArray = result.schema.type === 'array';
    result.schema.isBool = result.schema.type === 'boolean';
    // result.schema.examples = this._computeModelExamples(def);
    if (result.schema.isArray) {
      result.schema.items = items ? items : this._computeRawModelValue(model[DATA_VOC + '#items']);
    }
    result.schema.inputType = this._computeModelInputType(result.schema.type, result.schema.items);
    result.schema.pattern = this._computeModelPattern(result.schema.type, result.schema.pattern);
    const example = this._computeRawModelValue(model[DATA_VOC + '#example']);
    if (example) {
      result.schema.examples = [example];
    }
    const examples = this._computeRawExamples(model[DATA_VOC + '#examples']);
    if (examples) {
      const existing = result.schema.examples || [];
      result.schema.examples = existing.concat(examples);
    }
    return result;
  }
  /**
   * Sets up additional properties like `value` or placeholder from
   * values read from the AMF model.
   *
   * @param {Object} item Computed UI model.
   * @param {Object} processOptions Model creation options
   * @return {Object}
   */
  _processAfterItemCreated(item, processOptions) {
    if (item.schema.examples && item.schema.examples.length && item.schema.examples[0].value) {
      item.schema.inputPlaceholder = 'Example: ' +
        this._exampleAsValue(item.schema.examples[0].value, processOptions);
    }
    if (!item.schema.inputPlaceholder) {
      item.schema.inputPlaceholder = this._computeTypePlaceholder(item.type);
    }
    if (item.schema.inputPlaceholder) {
      item.schema.inputFloatLabel = true;
    }
    if (item.required && typeof item.schema.defaultValue !== 'undefined') {
      item.value = item.schema.isArray ?
        this.__parseArrayExample(item.schema.defaultValue, processOptions) :
        this._exampleAsValue(item.schema.defaultValue, processOptions);
    }
    if (typeof item.value === 'undefined' && item.required) {
      if (item.schema.examples) {
        item.value = this._exampleAsValue(item.schema.examples[0].value, processOptions);
      }
      if (typeof item.value === 'undefined' && item.schema.isEnum) {
        item.value = this._exampleAsValue(item.schema.enum[0], processOptions);
      }
    }

    if (item.value && item.schema.isArray && typeof item.value === 'string') {
      const _v = this.__parseArrayExample(item.value);
      item.value = _v instanceof Array ? _v : [_v];
    }

    if (item.schema.isArray && !item.value) {
      item.value = [''];
    }

    if (item.isBoolean && typeof item.value === 'boolean') {
      item.value = String(item.value);
    }
    return item;
  }
  /**
   * Completes computation of input label.
   *
   * @param {?String} displayName Value of the `displayName` property
   * @param {String} name Property name
   * @param {Boolean} required Is item required
   * @return {String} Common input label construction.
   */
  _completeInputLabel(displayName, name, required) {
    if (!displayName) {
      displayName = name || 'Input value';
    }
    if (required) {
      displayName += '*';
    }
    return displayName;
  }
  /**
   * Computes schema property of the view model from AMF model.
   *
   * @param {Object} model AFM json/ld model.
   * @param {Object} opts Options for model generation.
   * - required {Boolean} true if item is required.
   * - name {String} Property name
   * - valueDelimite {String}
   * - decodeValues {Boolean}
   * @return {Object} Schema part of the view model
   */
  _computeParameterSchema(model, opts) {
    opts = opts || {};
    const result = {};
    const key = RAML_V_HTTP + '#schema';
    if (!model[key]) {
      return;
    }
    const def = model[key][0];
    result.enabled = true;
    result.type = this._computeModelType(def);
    result.inputLabel = this._computeInputLabel(def, opts.required, opts.name);
    result.pattern = this._computeShaclProperty(def, 'pattern');
    result.minLength = this._computeShaclProperty(def, 'minLength');
    result.maxLength = this._computeShaclProperty(def, 'maxLength');
    result.defaultValue = this._computeShaclProperty(def, 'defaultValue');
    result.multipleOf = this._computeVocabularyShapeProperty(def, 'multipleOf');
    result.minimum = this._computeShaclProperty(def, 'minInclusive');
    result.maximum = this._computeShaclProperty(def, 'maxInclusive');
    result.enum = this._computeModelEnum(def);
    result.isEnum = !!result.enum;
    result.isArray = result.type === 'array';
    result.isBool = result.type === 'boolean';
    result.examples = this._computeModelExamples(def);
    result.items = result.isArray ? this._computeModelItems(def) : undefined;
    result.inputType = this._computeModelInputType(result.type, result.items);
    result.pattern = this._computeModelPattern(result.type, result.pattern);
    return result;
  }
  /**
   * Uses the json-ld library to expand context properties.
   * @param {Object} compacted Compacted form of the schema.
   * @return {Promise} Resolved promise to a restored object
   */
  _expandSchema(model, context) {
    const data = model[0];
    data['@context'] = context;
    /* global jsonld */
    return jsonld.expand(data);
  }
  /**
   * Computes list of examples from the Raw data model.
   * @param {Object} model
   * @return {Array|undefined}
   */
  _computeRawExamples(model) {
    if (!model || !model[0]) {
      return;
    }
    const result = [];
    model = model[0];
    const keys = Object.keys(model);
    keys.forEach((key) => {
      if (key.indexOf(DATA_VOC) === -1) {
        return;
      }
      const name = key.split('#')[1];
      const value = this._computeRawModelValue(model[key]);
      if (value) {
        result.push({
          name: name,
          value: value,
          hasName: !!name
        });
      }
    });
    return result;
  }
  /**
   * Checks if a model has a type.
   * @param {Object} model Model to test
   * @param {String} type Type name
   * @return {Boolean} True if model has a type.
   */
  _modelHasType(model, type) {
    let types = model && model['@type'] || [];
    for (let i = 0; i < types.length; i++) {
      if (types[i] === type) {
        return true;
      }
    }
    return false;
  }
  /**
   * Computes value of the `binding` property of the UI model.
   * @param {Object} model AMF item model
   * @return {String|undefined} Binding property or undefined if not found.
   */
  _computeBinding(model) {
    const key = RAML_V_HTTP + '#binding';
    if (!model[key]) {
      return;
    }
    return model[key][0]['@value'];
  }
  /**
   * Computes fomm (parameter) name from AMF model.
   * @param {Object} model AMF item model
   * @return {String|undefined} Name property or undefined if not found.
   */
  _computeFormName(model) {
    const key = SCHEMA + 'name';
    if (!model[key]) {
      return;
    }
    return model[key][0]['@value'];
  }
  /**
   * Computes description from AMF model.
   * @param {Object} model AMF item model
   * @return {String|undefined} Description property or undefined if not found.
   */
  _computeDescription(model) {
    const key = SCHEMA + 'description';
    if (!model[key]) {
      return;
    }
    return model[key][0]['@value'];
  }
  /**
   * Computes rwquired property from AMF model.
   * @param {Object} model AMF item model
   * @return {Boolean} True if the property is required.
   */
  _computeRequired(model) {
    const key = HYDRA_CORE + '#required';
    if (!model[key]) {
      return;
    }
    return model[key][0]['@value'];
  }
  /**
   * Computes type of the model. It's RAML data type property.
   * @param {Object} model Property schema.
   * @return {String} Type of the nproperty.
   */
  _computeModelType(model) {
    if (this._modelHasType(model, RAML_V_SHAPES + '#UnionShape')) {
      return 'union';
    }
    if (this._modelHasType(model, ARRAY_SHAPE)) {
      return 'array';
    }
    if (this._modelHasType(model, SHACL + '#ScalarShape')) {
      switch (model[SHACL + '#datatype'][0]['@id']) {
        case XML_SCHEMA + '#integer': return 'integer';
        case XML_SCHEMA + '#string': return 'string';
        case XML_SCHEMA + '#boolean': return 'boolean';
        case XML_SCHEMA + '#date': return 'date';
        case XML_SCHEMA + '#time': return 'time';
        case XML_SCHEMA + '#dateTime': return 'dateTime';
        case XML_SCHEMA + '#float': return 'float';
      }
    }
    return 'string';
  }
  /**
   * Computes type of the raw model.
   *
   * @param {Array} model Property schema.
   * @return {String|undefined} Type of the nproperty.
   */
  _computeRawModelValue(model) {
    if (!model || !model[0]) {
      return;
    }
    const item = model[0];
    const dataType = item['@type'][0];
    switch (dataType) {
      case DATA_VOC + '#Scalar':
        return this._computeRawScalarValue(item);
      case DATA_VOC + '#Array':
        return this._computeRawArrayValue(item);
    }
  }

  _computeRawScalarValue(item) {
    let value = item[DATA_VOC + '#value'];
    if (!value) {
      return;
    }
    value = value[0];
    const type = value['@type'];
    value = value['@value'];
    switch (type) {
      case XML_SCHEMA + '#number':
      case XML_SCHEMA + '#integer':
        return Number(value);
      case XML_SCHEMA + '#boolean':
        return value === 'false' ? false : true;
      default:
        return value;
    }
  }

  _computeRawArrayValue(item) {
    let values = item[RDF + '#member'];
    if (!values) {
      return;
    }
    const result = [];
    values.forEach((value) => {
      const item = this._computeRawScalarValue(value);
      if (item) {
        result.push(item);
      }
    });
    return;
  }
  /**
   * Computes form input label value.
   *
   * @param {Object} def Property definition
   * @param {Boolean} required True if the property is required
   * @param {?String} name Property name
   * @return {String} Input display name.
   */
  _computeInputLabel(def, required, name) {
    let result = def[SCHEMA + 'name'];
    if (result) {
      result = result[0]['@value'];
    }
    return this._completeInputLabel(result, name, required);
  }
  /**
   * Computes the value of a property that namespace starts with
   * `http://www.w3.org/ns/shacl`.
   *
   * @param {Object} def Property AMF definition
   * @param {String} property Name of the schema.
   * @return {any|undefined} Value of the property or undefined if not set.
   */
  _computeShaclProperty(def, property) {
    const key = SHACL + '#' + property;
    const val = def[key];
    if (val) {
      return val[0]['@value'];
    }
  }
  /**
   * Computes the value of a property that namespace starts with
   * `http://raml.org/vocabularies/shapes`.
   *
   * @param {Object} def Property AMF definition
   * @param {String} property Name of the schema.
   * @return {any|undefined} Value of the property or undefined if not set.
   */
  _computeVocabularyShapeProperty(def, property) {
    const key = RAML_V_SHAPES + '#' + property;
    const val = def[key];
    if (val) {
      return val[0]['@value'];
    }
  }
  /**
   * Computes enum values for the view model.
   * @param {[type]} def [description]
   * @return {[type]} [description]
   */
  _computeModelEnum(def) {
    const key = SHACL + '#in';
    const val = def[key];
    if (!val) {
      return;
    }
    const result = [];
    return this._computeEnumIterator(val, result);
  }
  /**
   * Computesa value for the `enum` property in the view model.
   * @param {Array} model Current model item for `shacl#in` namespace
   * @param {Array} result Collected values.
   * @return {Array} Final result.
   */
  _computeEnumIterator(model, result) {
    if (!model || !model.length) {
      return result;
    }
    model = model[0];
    const firstItem = this._getSchemaSafeValue(model, RDF + '#first');
    if (firstItem) {
      result.push(firstItem);
    }
    const val = model[RDF + '#rest'];
    if (!val) {
      return result;
    }
    return this._computeEnumIterator(val, result);
  }
  /**
   * Gets a value (`@value`) for a property without exceptions.
   *
   * @param {Object} model Model for the value.
   * @param {String} key Model key holding the value
   * @return {any|undefined}
   */
  _getSchemaSafeValue(model, key) {
    let root = model[key];
    if (!root) {
      return;
    }
    root = root[0];
    if (!root) {
      return;
    }
    return root['@value'];
  }
  /**
   * Computes list of examples for the Property model.
   *
   * @param {Object} model AMF property model
   * @return {Array<Object>|undefined} List of examples or `undefined` if not
   * defined.
   */
  _computeModelExamples(model) {
    const key = RAML_V_DOC + '#examples';
    const def = model[key];
    if (!def) {
      return;
    }
    const result = [];
    for (let i = 0, len = def.length; i < len; i++) {
      const item = def[i];
      const name = this._getSchemaSafeValue(item, SCHEMA + 'name');
      const value = this._getSchemaSafeValue(item, RAML_V_DOC + '#value');
      if (!name && !value) {
        continue;
      }
      result.push({
        name: name,
        value: value,
        hasName: !!name
      });
    }
    return result;
  }
  /**
   * Computes `items` property for AMF array property
   *
   * @param {Object} model AMF property model
   * @return {Object} Array definition model
   */
  _computeModelItems(model) {
    if (!this._modelHasType(model, ARRAY_SHAPE)) {
      return;
    }
    let inherits = model[RAML_V_SHAPES + '#inherits'];
    if (!inherits || !inherits.length) {
      console.warn('Expected #inherits declaration');
      return;
    }
    inherits = inherits[0];
    const items = inherits[RAML_V_SHAPES + '#items'];
    if (!items || !items.length) {
      console.warn('Expected #items declaration');
      return;
    }
    const item = items[0];
    const type = this._computeModelType(item);
    if (!type) {
      return;
    }
    // TODO: add support for objects and unions.
    return {
      type: type
    };
  }
  /**
   * Tests if current model part is actually a link to definition
   *
   * @param {Object} model Current model object.
   */
  _isLink(model) {
    const key = RAML_V_DOC+ '#link-target';
    return key in model;
  }
  /**
   * Attempty to resolve declaration of a link.
   * It tries tor use `amfDeclarations` property if it's set. Otherwise
   * it sends `amf-resolve-link` custom event to ask hosting application
   * for the data.
   *
   * @param {Object} model Model with `#link-target` property
   * @return {Object|undefined} Resolved declaration or undefined.
   */
  _importLink(model) {
    const key = RAML_V_DOC+ '#link-target';
    const def = model[key][0]['@id'];
    if (this.amfDeclarations) {
      return this._searchDeclaration(def);
    }
    return this._requestDeclaration(def);
  }
  /**
   * Searches `amfDeclarations` property for an id.
   *
   * @param {String} id Declaration ID
   * @return {Object|undefined} Model declaration or undefined if not found.
   */
  _searchDeclaration(id) {
    if (!this.amfDeclarations) {
      return;
    }
    return this.amfDeclarations.find((i) => i['@id'] === id);
  }
  /**
   * Dispatches `amf-resolve-link` custom event to ask hosting application
   * to resolve AMF model link.
   *
   * @param {String} id Declaration ID
   * @return {Object|undefined} Model declaration or undefined if not found.
   */
  _requestDeclaration(id) {
    const ev = new CustomEvent('amf-resolve-link', {
      detail: {
        id: id
      },
      cancelable: true,
      bubbles: true,
      composed: true
    });
    this.dispatchEvent(ev);
    return ev.detail.result;
  }

  _computeValueDelimiter(binding) {
    switch (binding) {
      case 'header': return ':';
      case 'query': return '=';
      default: return '';
    }
  }

  _computeDecodeValues(binding) {
    switch (binding) {
      case 'query': return true;
      default: return false;
    }
  }
  /**
   * Parses a string from example or enum value to be used as default value.
   * @param {String} example Example value to process as a value
   * @param {Object} opts Options:
   * - name {String} Processed property name
   * - valueDelimiter {?String} either `:` for headers or `=` for query params
   * - decodeValues {Boolean} True to url decode value.
   * @return {[type]} [description]
   */
  _exampleAsValue(example, opts) {
    if (!example || typeof example !== 'string') {
      return example;
    }
    example = example.trim();
    if (opts.valueDelimiter && example.indexOf(opts.name + opts.valueDelimiter) === 0) {
      example = example.substr(opts.name.length + 1);
    }
    if (opts.decodeValues) {
      try {
        example = decodeURIComponent(example.replace(/\+/g, ' '));
      } catch (e) {}
    }
    return example;
  }
  /**
   * Parses example in an array type.
   *
   * @param {String} example An array example
   * @param {Object} opts Options:
   * - name {String} Processed property name
   * - valueDelimiter {?String} either `:` for headers or `=` for query params
   * - decodeValues {Boolean} True to url decode value.
   * @return {Array} Array of examples or string if cannot parse
   */
  __parseArrayExample(example, processOptions) {
    try {
      const arr = JSON.parse(example);
      if (arr instanceof Array) {
        return arr.map(function(item) {
          return this._exampleAsValue(item, processOptions);
        }, this);
      }
      return this._exampleAsValue(example, processOptions);
    } catch (e) {}
    return this._exampleAsValue(example, processOptions);
  }

  /**
   * Computes rendered item input field type based on RAML definition.
   *
   * It will be either numeric or text. Type will be determined from
   * item's type or, in case of array, item's items property.
   *
   * @param {String} type Property data type.
   * @param {?Array} items Array items if any
   * @return {String} Input field type.
   */
  _computeModelInputType(type, items) {
    if (type === 'array') {
      if (typeof items === 'string') {
        return this.__computeInputType(items);
      }
      if (!items) {
        return 'string';
      }
      return this.__computeInputType(items.type);
    }
    return this.__computeInputType(type);
  }

  __computeInputType(type) {
    if (type && NUMBER_INPUT_TYPES.indexOf(type) !== -1) {
      return 'number';
    } else if (type === 'boolean') {
      return 'boolean';
    } else if (type === 'date-only' || type === 'date') {
      return 'date';
    } /*else if (type === 'time-only' || type === 'time') {
      return 'time';
    }*/
    return 'text';
  }
  /**
   * Computes pattern for the input.
   *
   * @param {String} modelType Type of the property item.
   * @param {String} pattern Pattern declared on the property
   * @return {String|undefined} Pattern or undefined if does not exists.
   */
  _computeModelPattern(modelType, pattern) {
    if (!pattern) {
      switch (modelType) {
        case 'time':
          pattern = '[0-9]{2}:[0-9]{2}:[0-9]{2}(\.[0-9])*';
          break;
        case 'date':
          pattern = '[0-9]{4}-[0-9]{2}-[0-9]{2}';
          break;
        case 'dateTime':
          pattern = '[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}(\.[0-9])*';
          break;
      }
    }
    return pattern;
  }
  /**
   * Computes a placeholder value for data and time inputs.
   *
   * @param {String} type Model type.
   * @return {String|undefined} Placeholder value.
   */
  _computeTypePlaceholder(type) {
    let value;
    switch (type) {
      case 'time':
        value = '00:00:00';
        break;
      case 'date':
        value = '0000-00-00';
        break;
      case 'dateTime':
        value = '0000-00-00T00:00:00';
        break;
    }
    return value;
  }
  /**
   * Handler for the `api-property-model-build` custom event.
   * Builds a property view model using event detail object as a base object.
   *
   * All changes are applied to the `detail` object. Requesting element must
   * use the same object.
   *
   * @param {CustomEvent} e
   */
  _buildPropertyHandler(e) {
    if (e.defaultPrevented) {
      return;
    }
    e.stopImmediatePropagation();
    e.preventDefault();
    this.buildProperty(e.detail);
  }
  /**
   * Builds empty view model without traversing AMF model.
   *
   * @param {?Object} defaults View model with default values. This values won't
   * be set.
   * @return {Object} Generated basic view model.
   */
  buildProperty(defaults) {
    if (!defaults) {
      defaults = {};
    }
    const modelDefaults = {
      name: 'property',
      schema: {
        type: 'string',
        isEnum: false,
        isArray: false,
        isBool: false,
        inputType: 'text'
      }
    };
    defaults = Object.assign(modelDefaults, defaults);
    defaults.hasDescription = !!defaults.description;
    defaults.schema.inputFloatLabel = (defaults.schema.inputFloatLabel || defaults.schema.inputPlaceholder) || false;
    defaults.schema.inputType = this._computeModelInputType(defaults.schema.type, defaults.schema.items);
    defaults.schema.pattern = this._computeModelPattern(defaults.schema.type, defaults.schema.pattern);
    if (!defaults.schema.inputLabel) {
      defaults.schema.inputLabel = defaults.name || 'Parameter value';
    }
    this._processAfterItemCreated(defaults, {});
    return defaults;
  }

  /**
   * Dispatched when the element is trying to resolve declaration link but
   * `amfDeclarations` is not set. It asks hosting application for the data for
   * the id.
   *
   * Handlers should cancel the event and set `result`property on event's
   * `detail` object with the declaration.
   *
   * @event amf-resolve-link
   * @param {String} id Declaration ID
   * @param {Object} result A placeholder for comupation result
   */
}
window.customElements.define(ApiViewModelTransformer.is, ApiViewModelTransformer);
})();
</script>

<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../events-target-behavior/events-target-behavior.html">
<link rel="import" href="../amf-helper-mixin/amf-helper-mixin.html">

<script>
(function() {
'use strict';
/**
 * @license
 * Copyright 2016 The Advanced REST client authors <arc@mulesoft.com>
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
const NUMBER_INPUT_TYPES = ['number', 'integer', 'float'];
const RAML_V_HTTP = 'http://raml.org/vocabularies/http';
const RAML_V_SHAPES = 'http://raml.org/vocabularies/shapes';
const RAML_V_DOC = 'http://raml.org/vocabularies/document';
const HYDRA_CORE = 'http://www.w3.org/ns/hydra/core';
const SCHEMA = 'http://schema.org/';
const SHACL = 'http://www.w3.org/ns/shacl';
const RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns';
const ARRAY_SHAPE = RAML_V_SHAPES + '#ArrayShape';
const XML_SCHEMA = 'http://www.w3.org/2001/XMLSchema';
const DATA_VOC = 'http://raml.org/vocabularies/data';
/**
 * An element to transform AMF LD model into a form view model.
 *
 * Note, this element does not include polyfills for `Promise` and `Array.from`.
 *
 * The model should be used to build a form view for request parameters
 * like header, query parameters, uri parameters or the body.
 *
 * ### Data model
 * - binding {String} - one of `path`, `query`, `header`
 * - name {String} - property (form) name
 * - required {Boolean} - is property required
 * - value {any} - Value of the property
 * - description {String} - The description of the property
 * - hasDescription {Boolean} - Flag describing if the property has a
 * description.
 * - properties {Array<Object>} - If the model is a type of object it is a list
 * of this model objects.
 * - schema {Object} - Property schma information
 * - schema.type {String} - Data type of the property
 * - schema.inputLabel {String} Label for the form control
 * - schema.inputType {String} - type attribute of the `input` element.
 * - schema.pattern {String} - Regex pattern of the property
 * - schema.minLength {Number} - String property minimum length
 * - schema.maxLength {Number} - String property maximum length
 * - schema.defaultValue {any} - Default value of the property
 * - schema.examples {Array<Object>} - List of examples for the form property.
 * - schema.multipleOf {Number} - For numeric values, a `step` attribute of
 * the `input` element.
 * Each object may contain `name` (may be undefined) and must contain `value`
 * property of the example.
 * - schema.minimum {Number} - For numeric values, minimum value of the property
 * - schema.maximum {Number} - For numeric values, maximum value of the property
 * - schema.isEnum {Boolean} - Flag describing enumerable value
 * - schema.enum {Array<any>} - Only if `schema.isEnum` is set. Values for enum
 * input.
 * - schema.isArray {Boolean} - Flag describing array value for the property
 * - schema.items {Object} - Lsit of items definitions
 * - schema.isBool {Boolean} - Flag describing boolean value for the property
 * - schema.isFile {Boolean} - Flag describing File value for the property
 * - schema.isObject {Boolean} - Flag describing Object value for the property
 * - schema.inputPlaceholder {?String} - A placeholder value for the input.
 * - schema.inputFloatLabel {Boolean} - Only if placeholder is set. Instructs
 * input control to float a label.
 * - schema.isUnion {Boolean} - Flag describing union value
 * - schema.anyOf {Array<Object>} - List of possible types of the union.
 * - schema.enabled {Boolean} - Always `true`
 * - schema.fileTypes {Array<String>} List of file types defined for a file
 * type.
 * ## Example
 *
 * ```html
 * <api-view-model-transformer on-view-model-changed="_updateView"></api-view-model-transformer>
 * <script>
 * const amfModel = getAmfFromRamlOrOas();
 * const processor = document.querySelector('api-view-model-transformer');
 * processor.amfModel = amfModel;
 * processor.shape = extractHeadersForMethod(amfModel);
 * processor.addEventListener('view-model-changed', (e) => {
 *  console.log(e.detail.value);
 * });
 * < /script>
 * ```
 *
 * This example uses `getAmfFromRamlOrOas()` function where you implement
 * the logic of getting AMF json/ld data. It can be stored in file or parsed
 * using AMF parsers. The `extractHeadersForMethod()` represents a logic to
 * extract properties that you want to transform. It can be headers, query
 * parameters or body type.
 *
 * ## JSON ld context
 *
 * JSON schema may contain `@context` property. It can be used to reduce size
 * of the schema by replacing namespace ids with defined in `@context` keywords.
 * This transformer does not consume whole AMF model, but only the portion that
 * should be transformed. Because of that the tranformer is missing context
 * for namespace resolving. Set `@context` value of the model to `amfContext`
 * property so it can be expanded to the canonical form.
 * **Tranformation won't work properly if namespace name are altered by context
 * and `amfContext` property is not set.**
 *
 * @customElement
 * @memberof ApiElements
 * @appliesMixin ArcBehaviors.EventsTargetBehavior
 * @appliesMixin ApiElements.AmfHelperMixin
 */
class ApiViewModelTransformer extends ApiElements.AmfHelperMixin(ArcBehaviors.EventsTargetBehavior(Polymer.Element)) {
  static get is() { return 'api-view-model-transformer'; }
  static get properties() {
    return {
      /**
       * Generated AMF json/ld model form the API spec.
       * The element assumes the object of the first array item to be a
       * type of `"http://raml.org/vocabularies/document#Document`
       * on AMF vocabulary.
       *
       * It is only used to resolve references.
       *
       * @type {Object|Array}
       */
      amfModel: Object,
      /**
       * An array of propertues for which view model is to be generated.
       * It accepts model for headers, query parameters, uri parameters and
       * body.
       * If `manualModel` is not set, assigning a value to this property will
       * trigger model computation. Otherwise call `computeViewModel()`
       * function manually to generate the model.
       */
      shape: {
        type: Array,
        observer: '_shapeChanged'
      },
      /**
       * Generated view model from the `shape`
       *
       * @type {Array<Object>}
       */
      viewModel: {
        type: Array,
        notify: true,
        readOnly: true
      },
      /**
       * If set, assigning a value to `shape` will not trigger view model
       * computation.
       */
      manualModel: Boolean,
      /**
       * The declarations model computed from the AMF object. It is used when the
       * transformer attempt to transform link value.
       *
       * If this property is not set then it dispatches `amf-resolve-link`
       * custom event.
       */
      _references: {
        type: Array,
        computed: '_computeReferences(amfModel)'
      }
    };
  }

  constructor() {
    super();
    this._buildPropertyHandler = this._buildPropertyHandler.bind(this);
  }

  _attachListeners(node) {
    node.addEventListener('api-property-model-build', this._buildPropertyHandler);
  }

  _detachListeners(node) {
    node.removeEventListener('api-property-model-build', this._buildPropertyHandler);
  }
  /**
   * Called when either `shape` or `manualModel` propeties changed.
   * If `manualModel` is falsy then it calls `computeViewModel()` function.
   *
   * Note, this function won't be called when sub property of the model
   * change. For peformance rerasons it won't be supported.
   *
   * Note, `computeViewModel` is called asynchronusly so `amfContext`
   * property can be set.
   *
   * @param {Array} shape Model for shape
   */
  _shapeChanged(shape) {
    if (this.manualModel) {
      return;
    }
    this.computeViewModel(shape);
  }
  /**
   * Computes view model from AMF data model. This should not be called if
   * `manualModel` is not set. Use `shape` property instead.
   *
   * @param {?Array|Object} shape AMF type model. If not set it uses `shape`
   * property of the element.
   * @return {Promise} A promise resolved to generated model.
   */
  computeViewModel(shape) {
    this._setViewModel(undefined);
    if (!shape) {
      shape = this.shape;
    }
    if (!shape) {
      return Promise.resolve();
    }
    if (shape instanceof Array) {
      shape = Array.from(shape);
    }
    return this._computeViewModelRecursive(shape)
    .then((model) => {
      this._setViewModel(model);
      return model;
    });
  }
  /**
   * Conputes model for each item recursively. It allows browser to return
   * the event loop and prohibit ANR to show.
   *
   * @param {Array} items List of remanding AMF model items.
   * This shuld be copy of the model since this function removes items from
   * the list.
   * @param {?Array} result Result of model comupation. It's repoted by
   * the Promise.
   * @return {Promise} Promise resolved to thre view model.
   */
  _computeViewModelRecursive(items, result) {
    result = result || [];
    if (!items) {
      return Promise.resolve(result);
    }
    const isArray = items instanceof Array;
    if (isArray && !items.length) {
      return Promise.resolve(result);
    }
    if (isArray) {
      const item = items.shift();
      const model = this.uiModelForAmfItem(item);
      if (model) {
        result.push(model);
      } else {
        console.warn('Unable to compute view data model for', item);
      }
      return Promise.resolve()
      .then(() => this._computeViewModelRecursive(items, result));
    }
    if (this._hasType(items, DATA_VOC + '#Object')) {
      return this.modelForRawObject(items);
    } else {
      return Promise.resolve(result);
    }
  }
  /**
   * Creates a UI model item from AMF json/ld model.
   * @param {Object} amfItem AMF model with schema for
   * `http://raml.org/vocabularies/http#Parameter`
   * @return {Object} UI data model.
   */
  uiModelForAmfItem(amfItem) {
    if (this._hasType(amfItem, RAML_V_HTTP + '#Parameter')) {
      return this._uiModelForParameter(amfItem);
    }
    if (this._hasType(amfItem, SHACL + '#PropertyShape')) {
      return this._uiModelForPropertyShape(amfItem);
    }
  }
  /**
   * Creates a UI model item from AMF json/ld model for a parameter.
   * @param {Object} amfItem AMF model with schema for
   * `http://raml.org/vocabularies/http#Parameter`
   * @return {Object} UI data model.
   */
  _uiModelForParameter(amfItem) {
    const result = {};
    result.binding = this._computeBinding(amfItem);
    const valueDelimiter = this._computeValueDelimiter(result.binding);
    const decodeValues = this._computeDecodeValues(result.binding);
    result.name = this._computeFormName(amfItem);
    result.description = this._computeDescription(amfItem);
    result.hasDescription = !!result.description;
    result.required = this._computeRequired(amfItem);
    const processOptions = {
      name: result.name,
      required: result.required,
      valueDelimiter: valueDelimiter,
      decodeValues: decodeValues
    };
    result.schema = this._computeParameterSchema(amfItem, processOptions);
    this._processAfterItemCreated(result, processOptions);
    return result;
  }
  /**
   * Creates a UI model item from AMF json/ld model for a parameter.
   * @param {Object} amfItem AMF model with schema for
   * `http://raml.org/vocabularies/http#Parameter`
   * @return {Object} UI data model.
   */
  _uiModelForPropertyShape(amfItem) {
    const result = {};
    result.binding = 'type';
    result.name = this._computeShaclProperty(amfItem, 'name');
    let def = amfItem[RAML_V_SHAPES + '#range'];
    if (!def) {
      return result;
    }
    def = def[0];
    result.description = this._computeDescription(def);
    result.hasDescription = !!result.description;
    result.required = this._computeRequired(def);
    result.schema = {};
    if (result.required === undefined) {
      result.required = false;
    }
    result.schema.enabled = true;
    result.schema.type = this._computeModelType(def);
    result.schema.inputLabel = this._computeInputLabel(def, result.required, result.name);
    result.schema.pattern = this._computeShaclProperty(def, 'pattern');
    result.schema.minLength = this._computeShaclProperty(def, 'minLength');
    result.schema.maxLength = this._computeShaclProperty(def, 'maxLength');
    result.schema.defaultValue = this._computeShaclProperty(def, 'defaultValue');
    result.schema.multipleOf = this._computeVocabularyShapeProperty(def, 'multipleOf');
    result.schema.minimum = this._computeShaclProperty(def, 'minInclusive');
    result.schema.maximum = this._computeShaclProperty(def, 'maxInclusive');
    result.schema.enum = this._computeModelEnum(def);
    result.schema.isEnum = !!result.schema.enum;
    result.schema.isArray = result.schema.type === 'array';
    result.schema.isObject = result.schema.type === 'object';
    result.schema.isBool = result.schema.type === 'boolean';
    result.schema.examples = this._computeModelExamples(def);
    result.schema.hasExamples = !!(result.schema.examples && result.schema.examples.length);
    result.schema.inputType = this._computeModelInputType(result.schema.type, result.schema.items);
    result.schema.pattern = this._computeModelPattern(result.schema.type, result.schema.pattern);
    result.hasExtendedDescs = this._computeHasExtendedDocumentation(result);
    if (result.hasDescription) {
      result.extendedDocs = this._computeExtendedDocumentation(result);
    }
    if (result.schema.type === 'file') {
      result.schema.isFile = true;
      result.schema.fileTypes = this._getValueArray(def, RAML_V_SHAPES + '#fileType');
    } else {
      result.schema.isFile = false;
    }
    if (result.schema.isObject) {
      const props = [];
      const items = def[SHACL + '#property'];
      if (items) {
        items.forEach((item) => props.push(this.uiModelForAmfItem(item)));
      }
      result.properties = props;
    }
    this._processAfterItemCreated(result, {});
    return result;
  }
  /**
   * Creates a view model for an object definition. Object definition can be
   * part of trait or annotation properties description.
   *
   * @param {Object} model Model to extract data from.
   * @param {Object} processOptions
   * @return {Array} View model for items.
   */
  modelForRawObject(model, processOptions) {
    if (!processOptions) {
      processOptions = {};
    }
    const result = [];
    const keys = Object.keys(model);
    keys.forEach((key) => {
      if (key.indexOf(DATA_VOC) === -1) {
        return;
      }
      let item = this._uiModelForRawObject(key, model[key][0]);
      if (item) {
        item = this._processAfterItemCreated(item, processOptions);
        result.push(item);
      }
    });
    return result;
  }
  /**
   * Creates a view model from "raw" item (model before resolving).
   *
   * @param {String} key Key of the item in the model.
   * @param {String} model Item model
   * @return {Object} View model
   */
  _uiModelForRawObject(key, model) {
    const name = key.split('#')[1];
    const result = {};
    result.binding = 'type';
    result.name = name;
    let type = this._computeRawModelValue(model[DATA_VOC + '#type']);
    if (!type) {
      type = 'string';
    }
    let bracetIndex = type.indexOf('[]');
    let items;
    if (bracetIndex !== -1) {
      items = type.substr(0, bracetIndex);
      type = 'array';
    }
    result.description = this._computeRawModelValue(model[DATA_VOC + '#description']);
    result.hasDescription = !!result.description;
    result.required = this._computeRawModelValue(model[DATA_VOC + '#required']);
    result.schema = {};
    result.schema.enabled = true;
    result.schema.type = type || 'string';
    const displayName = this._computeRawModelValue(model[DATA_VOC + '#displayName']);
    result.schema.inputLabel = this._completeInputLabel(displayName, name, result.required);
    result.schema.minLength = this._computeRawModelValue(model[DATA_VOC + 'minLength']);
    result.schema.maxLength = this._computeRawModelValue(model[DATA_VOC + 'maxLength']);
    result.schema.defaultValue = this._computeRawModelValue(model[DATA_VOC + 'default']);
    result.schema.multipleOf = this._computeRawModelValue(model[DATA_VOC + 'multipleOf']);
    result.schema.minimum = this._computeRawModelValue(model[DATA_VOC + 'minimum']);
    result.schema.maximum = this._computeRawModelValue(model[DATA_VOC + 'maximum']);
    result.schema.enum = this._computeRawModelValue(model[DATA_VOC + 'enum']);
    let pattern = this._computeRawModelValue(model[DATA_VOC + '#pattern']);
    if (pattern instanceof Array) {
      pattern = '[' + pattern[0] + ']';
    }
    result.schema.pattern = pattern;
    result.schema.isEnum = !!result.schema.enum;
    result.schema.isArray = result.schema.type === 'array';
    result.schema.isBool = result.schema.type === 'boolean';
    // result.schema.examples = this._computeModelExamples(def);
    if (result.schema.isArray) {
      result.schema.items = items ? items : this._computeRawModelValue(model[DATA_VOC + '#items']);
    }
    result.schema.inputType = this._computeModelInputType(result.schema.type, result.schema.items);
    result.schema.pattern = this._computeModelPattern(result.schema.type, result.schema.pattern);
    const example = this._computeRawModelValue(model[DATA_VOC + '#example']);
    if (example) {
      result.schema.examples = [example];
    }
    const examples = this._computeRawExamples(model[DATA_VOC + '#examples']);
    if (examples) {
      const existing = result.schema.examples || [];
      result.schema.examples = existing.concat(examples);
    }
    return result;
  }
  /**
   * Sets up additional properties like `value` or placeholder from
   * values read from the AMF model.
   *
   * @param {Object} item Computed UI model.
   * @param {Object} processOptions Model creation options
   * @return {Object}
   */
  _processAfterItemCreated(item, processOptions) {
    if (item.schema.examples && item.schema.examples.length && item.schema.examples[0].value) {
      item.schema.inputPlaceholder = 'Example: ' +
        this._exampleAsValue(item.schema.examples[0].value, processOptions);
    }
    if (!item.schema.inputPlaceholder) {
      item.schema.inputPlaceholder = this._computeTypePlaceholder(item.type);
    }
    if (item.schema.inputPlaceholder) {
      item.schema.inputFloatLabel = true;
    }
    if (item.required && typeof item.schema.defaultValue !== 'undefined') {
      item.value = item.schema.isArray ?
        this.__parseArrayExample(item.schema.defaultValue, processOptions) :
        this._exampleAsValue(item.schema.defaultValue, processOptions);
    }
    if (typeof item.value === 'undefined' && item.required) {
      const examples = item.schema.examples;
      if (examples && examples.length) {
        item.value = this._exampleAsValue(examples[0].value, processOptions);
      }
      if (typeof item.value === 'undefined' && item.schema.isEnum) {
        item.value = this._exampleAsValue(item.schema.enum[0], processOptions);
      }
    }

    if (item.value && item.schema.isArray && typeof item.value === 'string') {
      const _v = this.__parseArrayExample(item.value, processOptions);
      item.value = _v instanceof Array ? _v : [_v];
    }

    if (item.schema.isArray && !item.value) {
      item.value = [''];
    }

    if (item.isBoolean && typeof item.value === 'boolean') {
      item.value = String(item.value);
    }
    return item;
  }
  /**
   * Completes computation of input label.
   *
   * @param {?String} displayName Value of the `displayName` property
   * @param {String} name Property name
   * @param {Boolean} required Is item required
   * @return {String} Common input label construction.
   */
  _completeInputLabel(displayName, name, required) {
    if (!displayName) {
      displayName = name || 'Input value';
    }
    if (required) {
      displayName += '*';
    }
    return displayName;
  }
  /**
   * Computes schema property of the view model from AMF model.
   *
   * @param {Object} model AFM json/ld model.
   * @param {Object} opts Options for model generation.
   * - required {Boolean} true if item is required.
   * - name {String} Property name
   * - valueDelimite {String}
   * - decodeValues {Boolean}
   * @return {Object} Schema part of the view model
   */
  _computeParameterSchema(model, opts) {
    opts = opts || {};
    const result = {};
    const key = RAML_V_HTTP + '#schema';
    if (!model[key]) {
      return;
    }
    const def = model[key][0];
    result.enabled = true;
    result.type = this._computeModelType(def);
    result.inputLabel = this._computeInputLabel(def, opts.required, opts.name);
    result.pattern = this._computeShaclProperty(def, 'pattern');
    result.minLength = this._computeShaclProperty(def, 'minLength');
    result.maxLength = this._computeShaclProperty(def, 'maxLength');
    result.defaultValue = this._computeShaclProperty(def, 'defaultValue');
    result.multipleOf = this._computeVocabularyShapeProperty(def, 'multipleOf');
    result.minimum = this._computeShaclProperty(def, 'minInclusive');
    result.maximum = this._computeShaclProperty(def, 'maxInclusive');
    result.enum = this._computeModelEnum(def);
    result.isEnum = !!result.enum;
    result.isArray = result.type === 'array';
    result.isBool = result.type === 'boolean';
    result.isObject = result.type === 'object';
    result.examples = this._computeModelExamples(def);
    result.items = result.isArray ? this._computeModelItems(def) : undefined;
    result.inputType = this._computeModelInputType(result.type, result.items);
    result.pattern = this._computeModelPattern(result.type, result.pattern);
    return result;
  }
  /**
   * Computes list of examples from the Raw data model.
   * @param {Object} model
   * @return {Array|undefined}
   */
  _computeRawExamples(model) {
    if (!model || !model[0]) {
      return;
    }
    const result = [];
    model = model[0];
    const keys = Object.keys(model);
    keys.forEach((key) => {
      if (key.indexOf(DATA_VOC) === -1) {
        return;
      }
      const name = key.split('#')[1];
      const value = this._computeRawModelValue(model[key]);
      if (value) {
        result.push({
          name: name,
          value: value,
          hasName: !!name
        });
      }
    });
    return result;
  }
  /**
   * Computes value of the `binding` property of the UI model.
   * @param {Object} model AMF item model
   * @return {String|undefined} Binding property or undefined if not found.
   */
  _computeBinding(model) {
    const key = RAML_V_HTTP + '#binding';
    return this._getValue(model, key);
  }
  /**
   * Computes fomm (parameter) name from AMF model.
   * @param {Object} model AMF item model
   * @return {String|undefined} Name property or undefined if not found.
   */
  _computeFormName(model) {
    const key = SCHEMA + 'name';
    return this._getValue(model, key);
  }
  /**
   * Computes rwquired property from AMF model.
   * @param {Object} model AMF item model
   * @return {Boolean} True if the property is required.
   */
  _computeRequired(model) {
    const key = HYDRA_CORE + '#required';
    return this._getValue(model, key);
  }
  /**
   * Computes type of the model. It's RAML data type property.
   * @param {Object} shape Property schema.
   * @return {String} Type of the nproperty.
   */
  _computeModelType(shape) {
    if (!shape) {
      return;
    }
    if (this._hasType(shape, RAML_V_SHAPES + '#UnionShape')) {
      return 'union';
    }
    if (this._hasType(shape, RAML_V_SHAPES + '#ArrayShape')) {
      return 'array';
    }
    if (this._hasType(shape, 'http://www.w3.org/ns/shacl#NodeShape')) {
      return 'object';
    }
    if (this._hasType(shape, SHACL + '#PropertyShape')) {
      return 'object';
    }
    if (this._hasType(shape, RAML_V_SHAPES + '#FileShape')) {
      return 'file';
    }
    if (this._hasType(shape, RAML_V_SHAPES + '#NilShape')) {
      return 'null';
    }
    if (this._hasType(shape, RAML_V_SHAPES + '#AnyShape')) {
      return 'string';
    }
    if (this._hasType(shape, RAML_V_SHAPES + '#MatrixShape')) {
      return 'array';
    }
    if (this._hasType(shape, RAML_V_SHAPES+ '#TupleShape')) {
      return 'object';
    }
    if (this._hasType(shape, RAML_V_SHAPES + '#ScalarShape')) {
      switch (shape[SHACL + '#datatype'][0]['@id']) {
        case XML_SCHEMA + '#string': return 'string';
        case XML_SCHEMA + '#integer': return 'integer';
        case XML_SCHEMA + '#long': return 'long';
        case XML_SCHEMA + '#float': return 'float';
        case XML_SCHEMA + '#double': return 'double';
        case RAML_V_SHAPES + '#number': return 'number';
        case XML_SCHEMA + '#boolean': return 'boolean';
        case XML_SCHEMA + '#dateTime': return 'dateTime';
        case RAML_V_SHAPES + '#dateTimeOnly': return 'time';
        case XML_SCHEMA + '#time': return 'time';
        case XML_SCHEMA + '#date': return 'date';
        case XML_SCHEMA + '#base64Binary': return 'string';
        case RAML_V_SHAPES + '#password': return 'password';
      }
    }
    return 'string';
  }
  /**
   * Computes type of the raw model.
   *
   * @param {Array} model Property schema.
   * @return {String|undefined} Type of the nproperty.
   */
  _computeRawModelValue(model) {
    if (!model || !model[0]) {
      return;
    }
    const item = model[0];
    const dataType = item['@type'][0];
    switch (dataType) {
      case DATA_VOC + '#Scalar':
        return this._computeRawScalarValue(item);
      case DATA_VOC + '#Array':
        return this._computeRawArrayValue(item);
      case RAML_V_SHAPES + '#FileShape':
        return this._getValueArray(item, RAML_V_SHAPES + '#fileType');
    }
  }
  /**
   * Computes scalar value that has proper type.
   * @param {Object} item Shape to test for a value.
   * @return {String|Number|Boolean}
   */
  _computeRawScalarValue(item) {
    // http://raml.org/vocabularies/data#Scalar
    let value = item[DATA_VOC + '#value'];
    if (!value) {
      return;
    }
    value = value[0];
    const type = value['@type'];
    value = value['@value'];
    switch (type) {
      case XML_SCHEMA + '#number':
      case XML_SCHEMA + '#long':
      case XML_SCHEMA + '#integer':
      case XML_SCHEMA + '#float':
      case XML_SCHEMA + '#double':
        return Number(value);
      case XML_SCHEMA + '#boolean':
        return value === 'false' ? false : true;
      default:
        return value;
    }
  }

  _computeRawArrayValue(item) {
    let values = item[RDF + '#member'];
    if (!values) {
      return;
    }
    const result = [];
    values.forEach((value) => {
      const item = this._computeRawScalarValue(value);
      if (item) {
        result.push(item);
      }
    });
    return;
  }
  /**
   * Computes form input label value.
   *
   * @param {Object} def Property definition
   * @param {Boolean} required True if the property is required
   * @param {?String} name Property name
   * @return {String} Input display name.
   */
  _computeInputLabel(def, required, name) {
    let result = this._getValue(def, SCHEMA + 'name');
    return this._completeInputLabel(result, name, required);
  }
  /**
   * Computes the value of a property that namespace starts with
   * `http://www.w3.org/ns/shacl`.
   *
   * @param {Object} shape Property AMF definition
   * @param {String} property Name of the schema.
   * @return {any|undefined} Value of the property or undefined if not set.
   */
  _computeShaclProperty(shape, property) {
    const key = SHACL + '#' + String(property);
    return this._getValue(shape, key);
  }
  /**
   * Computes the value of a property that namespace starts with
   * `http://raml.org/vocabularies/shapes`.
   *
   * @param {Object} shape Property AMF definition
   * @param {String} property Name of the schema.
   * @return {any|undefined} Value of the property or undefined if not set.
   */
  _computeVocabularyShapeProperty(shape, property) {
    const key = RAML_V_SHAPES + '#' + String(property);
    return this._getValue(shape, key);
  }
  /**
   * Computes enum values for the view model.
   * @param {Object} def Model definition.
   * @return {Array} List of values.
   */
  _computeModelEnum(def) {
    const key = SHACL + '#in';
    let model = def[key];
    if (!model) {
      return;
    }
    model = model[0];
    const result = [];
    Object.keys(model).forEach((key) => {
      if (key.indexOf('http://www.w3.org/2000/01/rdf-schema#') === -1) {
        return;
      }
      const value = this._getValue(model, key);
      if (value) {
        result.push(value);
      }
    });
    return result;
  }
  /**
   * Computes list of examples for the Property model.
   *
   * @param {Object} model AMF property model
   * @return {Array<Object>|undefined} List of examples or `undefined` if not
   * defined.
   */
  _computeModelExamples(model) {
    const key = RAML_V_DOC + '#examples';
    const def = model[key];
    if (!def) {
      return;
    }
    const result = [];
    for (let i = 0, len = def.length; i < len; i++) {
      const item = def[i];
      const name = this._getValue(item, SCHEMA + 'name');
      const value = this._getExampleValue(item);
      if (!name && !value) {
        continue;
      }
      result.push({
        name: name,
        value: value,
        hasName: !!name
      });
    }
    return result;
  }
  /**
   * Computes `items` property for AMF array property
   *
   * @param {Object} model AMF property model
   * @return {Object} Array definition model
   */
  _computeModelItems(model) {
    if (!this._hasType(model, ARRAY_SHAPE)) {
      return;
    }
    const items = model[RAML_V_SHAPES + '#items'];
    if (!items) {
      console.warn('Expected #items declaration');
      return;
    }
    const item = items[0];
    const type = this._computeModelType(item);
    if (!type) {
      return;
    }
    // TODO: add support for objects and unions.
    return type;
  }
  /**
   * Tests if current model part is actually a link to definition
   *
   * @param {Object} model Current model object.
   */
  _isLink(model) {
    const key = RAML_V_DOC + '#link-target';
    return key in model;
  }
  /**
   * Attempty to resolve declaration of a link.
   * It tries tor use `_references` property if it's set. Otherwise
   * it sends `amf-resolve-link` custom event to ask hosting application
   * for the data.
   *
   * @param {Object} model Model with `#link-target` property
   * @return {Object|undefined} Resolved declaration or undefined.
   */
  _importLink(model) {
    const key = RAML_V_DOC + '#link-target';
    const def = model[key][0]['@id'];
    if (this._references) {
      return this._searchDeclaration(def);
    }
    return this._requestDeclaration(def);
  }
  /**
   * Searches `_references` property for an id.
   *
   * @param {String} id Declaration ID
   * @return {Object|undefined} Model declaration or undefined if not found.
   */
  _searchDeclaration(id) {
    if (!this._references) {
      return;
    }
    return this._references.find((i) => i['@id'] === id);
  }
  /**
   * Dispatches `amf-resolve-link` custom event to ask hosting application
   * to resolve AMF model link.
   *
   * @param {String} id Declaration ID
   * @return {Object|undefined} Model declaration or undefined if not found.
   */
  _requestDeclaration(id) {
    const ev = new CustomEvent('amf-resolve-link', {
      detail: {
        id: id
      },
      cancelable: true,
      bubbles: true,
      composed: true
    });
    this.dispatchEvent(ev);
    return ev.detail.result;
  }

  _computeValueDelimiter(binding) {
    switch (binding) {
      case 'header': return ':';
      case 'query': return '=';
      default: return '';
    }
  }

  _computeDecodeValues(binding) {
    switch (binding) {
      case 'query': return true;
      default: return false;
    }
  }
  /**
   * Parses a string from example or enum value to be used as default value.
   * @param {String} example Example value to process as a value
   * @param {Object} opts Options:
   * - name {String} Processed property name
   * - valueDelimiter {?String} either `:` for headers or `=` for query params
   * - decodeValues {Boolean} True to url decode value.
   * @return {[type]} [description]
   */
  _exampleAsValue(example, opts) {
    if (!example || typeof example !== 'string') {
      return example;
    }
    example = example.trim();
    if (opts.valueDelimiter && example.indexOf(opts.name + opts.valueDelimiter) === 0) {
      example = example.substr(opts.name.length + 1);
    }
    if (opts.decodeValues) {
      try {
        example = decodeURIComponent(example.replace(/\+/g, ' '));
      } catch (e) {}
    }
    return example;
  }
  /**
   * Parses example in an array type.
   *
   * @param {String} example An array example
   * @param {Object} opts Options:
   * - name {String} Processed property name
   * - valueDelimiter {?String} either `:` for headers or `=` for query params
   * - decodeValues {Boolean} True to url decode value.
   * @return {Array} Array of examples or string if cannot parse
   */
  __parseArrayExample(example, processOptions) {
    try {
      const arr = JSON.parse(example);
      if (arr instanceof Array) {
        return arr.map(function(item) {
          return this._exampleAsValue(item, processOptions);
        }, this);
      }
      return this._exampleAsValue(example, processOptions);
    } catch (e) {}
    return this._exampleAsValue(example, processOptions);
  }

  /**
   * Computes rendered item input field type based on RAML definition.
   *
   * It will be either numeric or text. Type will be determined from
   * item's type or, in case of array, item's items property.
   *
   * @param {String} type Property data type.
   * @param {?Array} items Array items if any
   * @return {String} Input field type.
   */
  _computeModelInputType(type, items) {
    if (type === 'array') {
      if (typeof items === 'string') {
        return this.__computeInputType(items);
      }
      if (!items) {
        return 'string';
      }
      return this.__computeInputType(items.type);
    }
    return this.__computeInputType(type);
  }

  __computeInputType(type) {
    if (type && NUMBER_INPUT_TYPES.indexOf(type) !== -1) {
      return 'number';
    } else if (type === 'boolean') {
      return 'boolean';
    } else if (type === 'date-only' || type === 'date') {
      return 'date';
    } /*else if (type === 'time-only' || type === 'time') {
      return 'time';
    }*/
    return 'text';
  }
  /**
   * Computes pattern for the input.
   *
   * @param {String} modelType Type of the property item.
   * @param {String} pattern Pattern declared on the property
   * @return {String|undefined} Pattern or undefined if does not exists.
   */
  _computeModelPattern(modelType, pattern) {
    if (!pattern) {
      switch (modelType) {
        case 'time':
          pattern = '[0-9]{2}:[0-9]{2}:[0-9]{2}(\.[0-9])*';
          break;
        case 'date':
          pattern = '[0-9]{4}-[0-9]{2}-[0-9]{2}';
          break;
        case 'dateTime':
          pattern = '[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}(\.[0-9])*';
          break;
      }
    }
    return pattern;
  }
  /**
   * Computes a placeholder value for data and time inputs.
   *
   * @param {String} type Model type.
   * @return {String|undefined} Placeholder value.
   */
  _computeTypePlaceholder(type) {
    let value;
    switch (type) {
      case 'time':
        value = '00:00:00';
        break;
      case 'date':
        value = '0000-00-00';
        break;
      case 'dateTime':
        value = '0000-00-00T00:00:00';
        break;
    }
    return value;
  }
  /**
   * Handler for the `api-property-model-build` custom event.
   * Builds a property view model using event detail object as a base object.
   *
   * All changes are applied to the `detail` object. Requesting element must
   * use the same object.
   *
   * @param {CustomEvent} e
   */
  _buildPropertyHandler(e) {
    if (e.defaultPrevented) {
      return;
    }
    e.stopImmediatePropagation();
    e.preventDefault();
    this.buildProperty(e.detail);
  }
  /**
   * Builds empty view model without traversing AMF model.
   *
   * @param {?Object} defaults View model with default values. This values won't
   * be set.
   * @return {Object} Generated basic view model.
   */
  buildProperty(defaults) {
    if (!defaults) {
      defaults = {};
    }
    // defaults.name = defaults.name || 'property';
    defaults.schema = defaults.schema || {};
    defaults.schema.type = defaults.schema.type || 'string';
    defaults.schema.isEnum = defaults.schema.isEnum || false;
    defaults.schema.isArray = defaults.schema.isArray || false;
    defaults.schema.isBool = defaults.schema.isBool || false;
    defaults.schema.isFile = defaults.schema.type === 'file';
    defaults.schema.inputType = defaults.schema.inputType === 'text';
    defaults.hasDescription = !!defaults.description;
    defaults.schema.inputFloatLabel = (defaults.schema.inputFloatLabel ||
      defaults.schema.inputPlaceholder) || false;
    defaults.schema.inputType = this._computeModelInputType(defaults.schema.type,
      defaults.schema.items);
    defaults.schema.pattern = this._computeModelPattern(defaults.schema.type,
      defaults.schema.pattern);
    if (!defaults.schema.inputLabel) {
      defaults.schema.inputLabel = defaults.name || 'Parameter value';
    }
    this._processAfterItemCreated(defaults, {});
    return defaults;
  }

  /**
   * Computes if model item has documentation to display.
   * This would be extended documentation by adding additional description
   * properties that helps the user to input values into the editor.
   *
   * @param {Object} item Model item
   * @return {Boolean} True if documentation can be rendered.
   */
  _computeHasExtendedDocumentation(item) {
    if (item.hasDescription) {
      return true;
    }
    if (!item.schema) {
      return false;
    }
    const schema = item.schema;
    if (schema.pattern) {
      return true;
    }
    if (schema.examples && schema.examples.length) {
      return true;
    }
    return false;
  }
  /**
   * Computes documentation as a markdown to be placed in the `marked-element`
   * @param {Object} item View model
   */
  _computeExtendedDocumentation(item) {
    let docs = '';
    if (item.description) {
      docs += item.description;
    }
    if (!item.schema) {
      return docs;
    }
    const schema = item.schema;
    docs += '\n\n\n';
    if (schema.pattern) {
      docs += '- Pattern: `' + schema.pattern + '`\n';
    }
    if (schema.examples && schema.examples.length) {
      schema.examples.forEach((item) => {
        docs += '- Example';
        if (item.hasName) {
          docs += ' ' + item.name;
        }
        docs += ': `' + item.value + '`\n';
      });
    }
    return docs;
  }
  /**
   * Creates an example body from a body property of AMF.
   * This object must be of a type of `http://raml.org/vocabularies/http#Payload`.
   *
   * @param {Object} body AMF body object
   * @return {String|undefined} An example body value if possible to compute.
   * It returns undefined if passed value if not a payload type. It may be empty
   * string.
   */
  bodyToExample(body) {
    if (!this._hasType(body, 'http://raml.org/vocabularies/http#Payload')) {
      return;
    }
    // First lets stry an example
    const schema = body[RAML_V_HTTP + '#schema'];
    if (!schema) {
      // there's nothing we can compute here
      return '';
    }
    const examples = this._computeModelExamples(schema[0]);
    if (examples && examples.length) {
      return examples[0].value;
    }
    const ct = this._getValue(body, 'http://raml.org/vocabularies/http#mediaType');
    switch (ct) {
      case 'application/json':
        return this.computeAmfDisplayJson(schema[0]['http://www.w3.org/ns/shacl#property']);
      case 'application/xml':
        return this._getValue(schema[0]['http://www.w3.org/ns/shacl#raw']) || '';
      default:
        return '';
    }
  }
  /**
   * Computes an example JSON display value from AMF model
   * @param {Array} properties List of AMF Prooperty models
   * @return {String} Example
   */
  computeAmfDisplayJson(properties) {
    if (!properties || !properties.length) {
      return '';
    }
    const result = {};
    properties.forEach((item) => {
      const model = this.uiModelForAmfItem(item);
      result[model.name] = model.value || model.schema.type || '';
    });
    return JSON.stringify(result, null, 2);
  }

  /**
   * Computes a JSON object to display from view model propertiers
   * @param {Array<Object>} properties
   * @return {String} JSON string value.
   */
  computeDisplayJson(properties) {
    const result = this._computeDisplayJsonRecursive(properties);
    return JSON.stringify(result, null, 2);
  }
  /**
   * Computes an XML schema to display from view model propertiers
   * @param {Array<Object>} properties
   * @return {String} XML string value.
   */
  computeDisplayXml(properties) {
    let result = '';
    if (!properties || !properties.length) {
      return result;
    }
    properties.forEach((item) => {
      const schema = item.schema;
      result += `<${item.name}>`;
      let v = schema.defaultValue;
      if (!v) {
        switch (true) {
          case schema.isEnum:
            v = schema.enum && schema.enum[0];
            break;
          case schema.isArray:
            v = schema.items;
            break;
          case schema.isBool:
            v = 'true';
            break;
          case schema.isFile:
            v = '';
            break;
          case schema.isObject:
            v = this.computeDisplayXml(item.properties);
            break;
          default:
            if (schema.hasExamples) {
              v = schema.examples[0].value || schema.examples[0];
            } else {
              v = schema.type;
            }
            break;
        }
      }
      result += v;
      result += `</${item.name}>\n`;
    });
    return result;
  }

  _computeDisplayJsonRecursive(properties, result) {
    result = result || {};
    if (!properties || !properties.length) {
      return result;
    }
    properties.forEach((item) => {
      const schema = item.schema;
      let v = schema.defaultValue;
      if (!v) {
        switch (true) {
          case schema.isEnum:
            v = schema.enum && schema.enum[0];
            break;
          case schema.isArray:
            v = schema.items;
            break;
          case schema.isBool:
            v = true;
            break;
          case schema.isFile:
            v = '';
            break;
          case schema.isObject:
            v = this._computeDisplayJsonRecursive(item.properties);
            break;
          default:
            if (schema.hasExamples) {
              v = schema.examples[0].value || schema.examples[0];
            } else {
              v = schema.type;
            }
            break;
        }
      }
      result[item.name] = v || '';
    });
    return result;
  }
  /**
   * Dispatched when the element is trying to resolve declaration link but
   * `_references` is not set. It asks hosting application for the data for
   * the id.
   *
   * Handlers should cancel the event and set `result`property on event's
   * `detail` object with the declaration.
   *
   * @event amf-resolve-link
   * @param {String} id Declaration ID
   * @param {Object} result A placeholder for comupation result
   */
}
window.customElements.define(ApiViewModelTransformer.is, ApiViewModelTransformer);
})();
</script>
